<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lecture</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="02_07_lecture_files/libs/clipboard/clipboard.min.js"></script>
<script src="02_07_lecture_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="02_07_lecture_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="02_07_lecture_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="02_07_lecture_files/libs/quarto-html/popper.min.js"></script>
<script src="02_07_lecture_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="02_07_lecture_files/libs/quarto-html/anchor.min.js"></script>
<link href="02_07_lecture_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="02_07_lecture_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="02_07_lecture_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="02_07_lecture_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="02_07_lecture_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="lecture-2.7-ramsey-interferometry-and-noisy-qubits" class="level1">
<h1>Lecture 2.7: Ramsey Interferometry and Noisy Qubits</h1>
<section id="motivation-the-most-precise-measurements-ever-made" class="level2">
<h2 class="anchored" data-anchor-id="motivation-the-most-precise-measurements-ever-made">Motivation: The Most Precise Measurements Ever Made</h2>
<p>Last lecture we learned how qubits evolve in time: - <span class="math inline">\(H \propto \sigma_z\)</span>: precession (phase accumulates) - <span class="math inline">\(H \propto \sigma_x\)</span>: Rabi oscillations (populations change)</p>
<p>Today we combine these to build an <strong>interferometer</strong> — the same split → phase → recombine pattern we saw with light in the Mach-Zehnder interferometer.</p>
<p>This isn’t just an academic exercise. The Ramsey interferometer is the basis of: - <strong>Atomic clocks</strong> — defining the second itself - <strong>GPS</strong> — navigation accurate to meters - <strong>Magnetometers</strong> — measuring fields at the quantum limit</p>
<p>But there’s a catch: <strong>decoherence</strong>. The environment fights back, scrambling our carefully accumulated phase. Understanding decoherence is essential for quantum computing and sensing.</p>
<hr>
</section>
<section id="part-1-atomic-clocks-the-application" class="level2">
<h2 class="anchored" data-anchor-id="part-1-atomic-clocks-the-application">Part 1: Atomic Clocks — The Application</h2>
<section id="the-goal" class="level3">
<h3 class="anchored" data-anchor-id="the-goal">The Goal</h3>
<p>We want to build a clock based on atoms. Why atoms?</p>
<p>Every cesium atom in the universe is identical. The energy splitting between two hyperfine levels is a <strong>constant of nature</strong>:</p>
<p><span class="math display">\[\nu_{\text{Cs}} = 9,192,631,770 \text{ Hz}\]</span></p>
<p>This isn’t a measurement — it’s the <strong>definition of the second</strong> since 1967. If we can lock an oscillator to this frequency, we have a perfect clock.</p>
</section>
<section id="the-ramsey-sequence" class="level3">
<h3 class="anchored" data-anchor-id="the-ramsey-sequence">The Ramsey Sequence</h3>
<p>Here’s how an atomic clock works:</p>
<ol type="1">
<li><p><strong>Prepare</strong> atoms in state <span class="math inline">\(|0\rangle\)</span> (one hyperfine level)</p></li>
<li><p><strong>π/2-pulse:</strong> Apply a pulse from a local oscillator at frequency <span class="math inline">\(\omega_{LO}\)</span> <span class="math display">\[|0\rangle \xrightarrow{R_x(\pi/2)} \frac{1}{\sqrt{2}}(|0\rangle - i|1\rangle)\]</span></p>
<p>This creates a superposition — the atom is now in both states simultaneously.</p></li>
<li><p><strong>Free evolution for time <span class="math inline">\(T\)</span>:</strong> The atom precesses. If <span class="math inline">\(\omega_{LO} \neq \omega_0\)</span> (the true atomic frequency), a phase accumulates: <span class="math display">\[\phi = (\omega_0 - \omega_{LO}) \cdot T\]</span></p></li>
<li><p><strong>Second π/2-pulse:</strong> This converts the accumulated phase into a population difference.</p></li>
<li><p><strong>Measure:</strong> Count how many atoms are in <span class="math inline">\(|0\rangle\)</span> vs <span class="math inline">\(|1\rangle\)</span>.</p></li>
<li><p><strong>Feedback:</strong> Adjust <span class="math inline">\(\omega_{LO}\)</span> to minimize the phase error.</p></li>
</ol>
<p>The feedback loop locks the local oscillator to the atomic transition. The oscillator’s ticks become “atomic ticks.”</p>
</section>
<section id="why-this-works-the-key-insight" class="level3">
<h3 class="anchored" data-anchor-id="why-this-works-the-key-insight">Why This Works: The Key Insight</h3>
<p>The Ramsey sequence is an <strong>interferometer for spin</strong>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Mach-Zehnder (light)</th>
<th>Ramsey (spin)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Beam splitter</td>
<td>π/2-pulse</td>
</tr>
<tr class="even">
<td>Path length difference → phase</td>
<td>Frequency detuning × time → phase</td>
</tr>
<tr class="odd">
<td>Second beam splitter</td>
<td>Second π/2-pulse</td>
</tr>
<tr class="even">
<td>Detector intensity</td>
<td>Population measurement</td>
</tr>
</tbody>
</table>
<p>The π/2-pulses play the role of beam splitters: they create and recombine superpositions. The free evolution time <span class="math inline">\(T\)</span> is where the “measurement” happens — phase accumulates proportional to the quantity we want to measure.</p>
<hr>
</section>
</section>
<section id="iclicker-question-1" class="level2">
<h2 class="anchored" data-anchor-id="iclicker-question-1">iClicker Question 1</h2>
<p><strong>In the Ramsey sequence, what is the role of the first π/2-pulse?</strong></p>
<ul>
<li><ol type="A">
<li>It flips the qubit from <span class="math inline">\(|0\rangle\)</span> to <span class="math inline">\(|1\rangle\)</span></li>
</ol></li>
<li><ol start="2" type="A">
<li>It creates a superposition of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> ✓</li>
</ol></li>
<li><ol start="3" type="A">
<li>It measures the qubit’s state</li>
</ol></li>
<li><ol start="4" type="A">
<li>It accumulates phase</li>
</ol></li>
</ul>
<p><strong>Answer:</strong> (B). The first π/2-pulse is like a beam splitter — it takes the input state <span class="math inline">\(|0\rangle\)</span> and creates an equal superposition. This is essential: you need a superposition to accumulate a <em>relative</em> phase during free evolution. A π-pulse (option A) would flip to <span class="math inline">\(|1\rangle\)</span>, but that’s still a definite state with no relative phase to measure.</p>
<hr>
</section>
<section id="part-2-the-ramsey-calculation" class="level2">
<h2 class="anchored" data-anchor-id="part-2-the-ramsey-calculation">Part 2: The Ramsey Calculation</h2>
<p>Let’s work through the math to see where the signal comes from.</p>
<section id="step-1-initial-state" class="level3">
<h3 class="anchored" data-anchor-id="step-1-initial-state">Step 1: Initial State</h3>
<p><span class="math display">\[|\psi_0\rangle = |0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix}\]</span></p>
</section>
<section id="step-2-first-π2-pulse" class="level3">
<h3 class="anchored" data-anchor-id="step-2-first-π2-pulse">Step 2: First π/2-pulse</h3>
<p><span class="math display">\[R_x(\pi/2) = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; -i \\ -i &amp; 1 \end{pmatrix}\]</span></p>
<p><span class="math display">\[|\psi_1\rangle = R_x(\pi/2)|0\rangle = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 \\ -i \end{pmatrix} = \frac{1}{\sqrt{2}}(|0\rangle - i|1\rangle)\]</span></p>
<p>The state is now on the equator of the Bloch sphere.</p>
</section>
<section id="step-3-free-evolution-phase-accumulation" class="level3">
<h3 class="anchored" data-anchor-id="step-3-free-evolution-phase-accumulation">Step 3: Free Evolution (Phase Accumulation)</h3>
<p>During free evolution, the Hamiltonian is <span class="math inline">\(H = \frac{\hbar\omega_0}{2}\sigma_z\)</span>. This gives rotation around z:</p>
<p><span class="math display">\[R_z(\phi) = \begin{pmatrix} e^{-i\phi/2} &amp; 0 \\ 0 &amp; e^{i\phi/2} \end{pmatrix}\]</span></p>
<p>where <span class="math inline">\(\phi = \omega_0 T\)</span> (or more precisely, <span class="math inline">\(\phi = (\omega_0 - \omega_{LO})T\)</span> in the rotating frame).</p>
<p>```aggxhtyzljvp The Rotating Frame :class: tip</p>
<p>Why do we write <span class="math inline">\(\phi = (\omega_0 - \omega_{LO})T\)</span> instead of just <span class="math inline">\(\omega_0 T\)</span>?</p>
<p>We work in a reference frame that rotates at the local oscillator frequency <span class="math inline">\(\omega_{LO}\)</span>. In this frame, we only see the <em>difference</em> frequency.</p>
<p>Analogy: Imagine watching a ceiling fan while riding a merry-go-round. If the merry-go-round spins at nearly the same rate as the fan, the fan appears to rotate slowly. The “slow” rotation you see is the difference between the two rates.</p>
<p>In atomic clocks, we tune <span class="math inline">\(\omega_{LO}\)</span> very close to <span class="math inline">\(\omega_0\)</span>, so the phase accumulates slowly — this is what lets us measure tiny frequency differences.</p>
<pre><code>
$$|\psi_2\rangle = R_z(\phi)|\psi_1\rangle = \frac{1}{\sqrt{2}}\begin{pmatrix} e^{-i\phi/2} \\ -ie^{i\phi/2} \end{pmatrix}$$

### Step 4: Second π/2-pulse

$$|\psi_3\rangle = R_x(\pi/2)|\psi_2\rangle = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; -i \\ -i &amp; 1 \end{pmatrix} \cdot \frac{1}{\sqrt{2}}\begin{pmatrix} e^{-i\phi/2} \\ -ie^{i\phi/2} \end{pmatrix}$$

Working through the matrix multiplication:

$$= \frac{1}{2}\begin{pmatrix} e^{-i\phi/2} + i \cdot ie^{i\phi/2} \\ -ie^{-i\phi/2} - ie^{i\phi/2} \end{pmatrix} = \frac{1}{2}\begin{pmatrix} e^{-i\phi/2} - e^{i\phi/2} \\ -i(e^{-i\phi/2} + e^{i\phi/2}) \end{pmatrix}$$

Using Euler's formula: $e^{i\theta} - e^{-i\theta} = 2i\sin\theta$ and $e^{i\theta} + e^{-i\theta} = 2\cos\theta$:

$$|\psi_3\rangle = \frac{1}{2}\begin{pmatrix} -2i\sin(\phi/2) \\ -2i\cos(\phi/2) \end{pmatrix} = -i\begin{pmatrix} \sin(\phi/2) \\ \cos(\phi/2) \end{pmatrix}$$

### Step 5: Measurement Probabilities

$$P_0 = |\langle 0|\psi_3\rangle|^2 = \sin^2(\phi/2)$$

$$P_1 = |\langle 1|\psi_3\rangle|^2 = \cos^2(\phi/2)$$

### The Ramsey Result

$$\boxed{P_0 = \sin^2\frac{\omega_0 T}{2} = \frac{1 - \cos(\omega_0 T)}{2}}$$

The probability oscillates sinusoidally with the accumulated phase!

### Ramsey Fringes

As we vary $T$ (or scan the detuning), $P_0$ oscillates. These oscillations are called **Ramsey fringes**.

```python
import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

# Ramsey sequence: Rx(π/2) - Rz(φ) - Rx(π/2)
phases = np.linspace(0, 4*np.pi, 100)
P0_ramsey = []

for phi in phases:
    qc = QuantumCircuit(1)
    qc.rx(np.pi/2, 0)   # First π/2 pulse
    qc.rz(phi, 0)       # Free evolution (phase accumulation)
    qc.rx(np.pi/2, 0)   # Second π/2 pulse
    
    state = Statevector(qc)
    P0_ramsey.append(state.probabilities()[0])

# Compare to theory
P0_theory = np.sin(phases/2)**2

plt.figure(figsize=(10, 5))
plt.plot(phases/np.pi, P0_ramsey, 'b-', linewidth=2, label='Qiskit simulation')
plt.plot(phases/np.pi, P0_theory, 'r--', linewidth=2, label='Theory: $\\sin^2(\\phi/2)$')
plt.xlabel('Phase $\\phi/\\pi$', fontsize=14)
plt.ylabel('$P_0$', fontsize=14)
plt.title('Ramsey Fringes', fontsize=16)
plt.legend(fontsize=12)
plt.grid(True, alpha=0.3)
plt.show()</code></pre>
<hr>
</section>
</section>
<section id="part-3-resolution-how-long-can-you-wait" class="level2">
<h2 class="anchored" data-anchor-id="part-3-resolution-how-long-can-you-wait">Part 3: Resolution — How Long Can You Wait?</h2>
<section id="the-frequency-resolution" class="level3">
<h3 class="anchored" data-anchor-id="the-frequency-resolution">The Frequency Resolution</h3>
<p>The fringes oscillate with period <span class="math inline">\(\Delta\phi = 2\pi\)</span>, corresponding to:</p>
<p><span class="math display">\[\Delta T = \frac{2\pi}{\omega_0}\]</span></p>
<p>The longer you wait (larger <span class="math inline">\(T\)</span>), the more sensitive you are to small frequency differences. The frequency resolution is:</p>
<p><span class="math display">\[\delta\omega \sim \frac{1}{T}\]</span></p>
<p>This is the time-energy uncertainty relation at work.</p>
</section>
<section id="ramseys-insight" class="level3">
<h3 class="anchored" data-anchor-id="ramseys-insight">Ramsey’s Insight</h3>
<p>Before Ramsey, people tried to measure atomic frequencies by applying a long continuous pulse. Problem: to get resolution <span class="math inline">\(\delta\omega\)</span>, you need pulse duration <span class="math inline">\(\sim 1/\delta\omega\)</span>.</p>
<p><strong>Ramsey’s breakthrough:</strong> Separate the “probing” from the “measuring.”</p>
<ul>
<li>The π/2-pulses can be <strong>short</strong> (microseconds) — easy to control</li>
<li>The free evolution can be <strong>long</strong> (seconds) — this sets the resolution</li>
<li>The resolution is <span class="math inline">\(\delta\omega \sim 1/T\)</span>, set by free evolution time, not pulse duration</li>
</ul>
<p>You get the precision of a very long measurement with the experimental control of short pulses.</p>
<p>```aggxhtyzljvp Norman Ramsey’s Nobel Prize :class: note</p>
<p>Norman Ramsey received the 1989 Nobel Prize in Physics for developing this “separated oscillatory fields” method. It is the foundation of all modern atomic clocks and precision spectroscopy.</p>
<pre><code>
---

## Part 4: Real Atomic Clocks

### Cesium Fountain Clocks

The current standard uses **cesium-133** atoms:

- **The transition:** Hyperfine splitting in the ground state — the two spin states of the cesium nucleus coupled to the electron
- **Frequency:** 9.192631770 GHz (microwave/RF)
- **How it works:** 
  - Laser-cool cesium atoms to microkelvin temperatures
  - Launch them upward in a "fountain" 
  - Apply π/2-pulse as they rise
  - Atoms coast upward, stop, fall back down (free evolution time $T \approx 0.5$ s)
  - Apply second π/2-pulse as they fall
  - Detect fluorescence to measure populations

**Performance:**
- Fractional accuracy: $\sim 10^{-16}$
- This means: gains or loses 1 second in **300 million years**

### Optical Atomic Clocks — The Future

The frequency resolution goes as $\delta\omega/\omega_0 \sim 1/(\omega_0 T)$.

**Key insight:** Higher frequency $\omega_0$ means better *fractional* precision for the same $T$.

Optical clocks use transitions at **visible light frequencies** ($\sim 10^{14}$ Hz) instead of microwave ($\sim 10^{10}$ Hz) — a factor of 10,000 improvement!

**Strontium optical lattice clocks:**
- **The transition:** Narrow "clock transition" in strontium at 429 THz
- **Fractional accuracy:** $\sim 10^{-18}$
- This means: gains or loses 1 second in **longer than the age of the universe**

### Measuring Gravity with Clocks

At $10^{-18}$ precision, clocks become sensitive to **general relativity**.

Einstein's theory predicts that clocks run faster in weaker gravitational fields. On Earth:

$$\frac{\Delta f}{f} \approx \frac{g \Delta h}{c^2} \approx 10^{-16} \text{ per meter of height}$$

With $10^{-18}$ clocks, you can detect the gravitational redshift from raising the clock by **1 centimeter**.

This has been demonstrated experimentally — optical clocks can measure the height difference between two labs!

---

## Part 5: Why Do We Need This Accuracy? GPS

### The Problem GPS Solves

Your phone determines its position by measuring the **time delay** of signals from multiple satellites. The distance to each satellite is:

$$d = c \cdot \Delta t$$

From multiple distances, you triangulate your position.

### The Precision Required

- Light travels ~30 cm in 1 nanosecond
- For 1 meter position accuracy, you need ~3 ns timing accuracy
- Over one day, the satellite clocks can't drift by more than ~100 ns
- This requires fractional stability of $\sim 10^{-12}$ to $10^{-14}$

**Without atomic clocks, GPS errors would accumulate at kilometers per day.**

Each GPS satellite carries cesium and rubidium atomic clocks. The ground stations use even better clocks to calibrate them.

### Relativity in Your Pocket

GPS satellites orbit at ~20,000 km altitude, moving at ~14,000 km/hr. Both effects matter:

| Effect | Time shift | Direction |
|--------|------------|-----------|
| Gravitational (weaker gravity at altitude) | +45 μs/day | Clocks run **faster** |
| Velocity (special relativity) | −7 μs/day | Clocks run **slower** |
| **Net effect** | +38 μs/day | Clocks run **faster** |

If uncorrected, this would cause position errors of ~10 km per day!

The GPS system corrects for relativity. **Every time you use GPS, you're testing Einstein's theories.**

---

## iClicker Question

**An atomic clock uses a Ramsey sequence with free evolution time** $T = 1$ **second. What is the approximate frequency resolution?**

- (A) 1 Hz ✓
- (B) 1 kHz
- (C) 1 MHz
- (D) 1 GHz

**Solution:** The frequency resolution is $\delta f \sim 1/T = 1/1\text{ s} = 1$ Hz.

For the cesium transition at $\nu_0 = 9.2$ GHz, this gives fractional precision $\delta\nu/\nu_0 \sim 10^{-10}$ — and that's per single measurement. Averaging many measurements improves this further.

---

## Part 6: Quantum Sensing — The General Framework

Atomic clocks measure **frequency**. But the same technique measures anything that shifts the qubit's energy levels.

### The Pattern

Any perturbation that causes $H = \frac{\hbar\omega}{2}\sigma_z$ leads to phase accumulation:

$$\phi = \omega \cdot T$$

If $\omega$ depends on some physical quantity $X$, measuring $\phi$ measures $X$:

$$X \to \omega(X) \to \phi = \omega T \to P_0 = \sin^2(\phi/2)$$

### Example: Magnetometry

An electron spin in a magnetic field $B$ has Larmor frequency:

$$\omega = \gamma_e B$$

where $\gamma_e = 2\pi \times 28$ GHz/T is the electron gyromagnetic ratio.

A Ramsey sequence with free evolution time $T$ gives phase $\phi = \gamma_e B T$.

**Sensitivity:** The minimum detectable field change:

$$\delta B = \frac{\delta\phi}{\gamma_e T}$$

Longer $T$ → better sensitivity.

### The Quantum Advantage: 1/T vs 1/√T

**Classical sensors** (e.g., measuring deflection, voltage):
- Sensitivity improves by averaging: $\delta X \propto 1/\sqrt{T}$

**Quantum sensors** (Ramsey interferometry):
- Phase accumulates coherently: $\delta X \propto 1/T$

For long measurement times, quantum sensors win!

This is the **Standard Quantum Limit**. With entanglement, you can do even better (the Heisenberg Limit), but that's for Chapter 4.

---

## iClicker Question 2

**In a Ramsey experiment, random phase noise from the environment will cause:**

- (A) The fringes to shift left or right
- (B) The fringes to oscillate faster
- (C) The fringe contrast to decrease ✓
- (D) The fringe contrast to increase

**Answer:** (C). Random phase kicks don't systematically shift the fringes (that would require a consistent bias). Instead, each experimental run sees a different random phase, so when we average many runs, the peaks and troughs average toward 1/2. The fringes "wash out" — the contrast decreases.

---

## Part 7: Decoherence — The Enemy of Quantum

Everything we've discussed assumes perfect, isolated qubits. Reality is messier.

### The Problem

In the real world, qubits interact with their environment:
- Stray magnetic fields
- Thermal fluctuations
- Nearby charges
- Vibrations in the material

These interactions cause **random, uncontrolled evolution** that scrambles our carefully prepared quantum states.

### Decoherence in the Ramsey Interferometer

Our Ramsey sequence is the perfect laboratory to understand decoherence.

**Ideal case:** During free evolution, the qubit accumulates a precise phase $\phi = \omega_0 T$.

**With decoherence:** The qubit experiences random phase kicks from the environment. Each run of the experiment sees a slightly different total phase:

$$\phi_{\text{actual}} = \omega_0 T + \phi_{\text{random}}$$

### What Happens to the Fringes?

Imagine running the Ramsey experiment many times. Each time:
- The intended phase is $\phi = \omega_0 T$
- But there's also a random kick $\delta\phi$ drawn from some distribution

When we average over many runs:

$$\langle P_0 \rangle = \left\langle \sin^2\frac{\phi + \delta\phi}{2} \right\rangle$$

If $\delta\phi$ has a wide distribution, the sin² function averages out toward 1/2.

**The fringes wash out.**

### Simulating Decoherence

This is exactly what you'll do in your homework! Add random phase noise to the Ramsey sequence:

```python
import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector

def ramsey_with_noise(phi, noise_strength):
    """Ramsey sequence with random dephasing noise."""
    qc = QuantumCircuit(1)
    qc.rx(np.pi/2, 0)
    
    # Intended phase + random noise
    random_phase = np.random.normal(0, noise_strength)
    qc.rz(phi + random_phase, 0)
    
    qc.rx(np.pi/2, 0)
    return Statevector(qc).probabilities()[0]

# Average over many runs to see the effect
def ramsey_averaged(phi, noise_strength, n_trials=100):
    return np.mean([ramsey_with_noise(phi, noise_strength) for _ in range(n_trials)])</code></pre>
<p>With increasing noise strength, you’ll see the fringe contrast decay — exactly what happens in real experiments.</p>
<hr>
</section>
</section>
<section id="part-8-mechanisms-of-decoherence" class="level2">
<h2 class="anchored" data-anchor-id="part-8-mechanisms-of-decoherence">Part 8: Mechanisms of Decoherence</h2>
<p>Different physical systems have different dominant noise sources.</p>
<section id="neutral-atoms" class="level3">
<h3 class="anchored" data-anchor-id="neutral-atoms">Neutral Atoms</h3>
<p><strong>Main source:</strong> Fluctuating magnetic fields</p>
<p>Even in a well-shielded lab, there are stray fields from: - Earth’s magnetic field fluctuations - Nearby electronics - Other atoms</p>
<p>The Zeeman shift <span class="math inline">\(\Delta E = \gamma B\)</span> converts field fluctuations into phase noise.</p>
<p><strong>Typical <span class="math inline">\(T_2\)</span>:</strong> ~1 second (with magnetic shielding)</p>
</section>
<section id="superconducting-qubits" class="level3">
<h3 class="anchored" data-anchor-id="superconducting-qubits">Superconducting Qubits</h3>
<p><strong>Main sources:</strong> - Flux noise (fluctuating magnetic fields through the circuit loop) - Charge noise (stray electrons hopping on/off nearby defects) - Two-level systems in the materials</p>
<p><strong>Typical <span class="math inline">\(T_2\)</span>:</strong> ~100 microseconds (improving rapidly with better materials)</p>
</section>
<section id="solid-state-emitters-nv-centers-quantum-dots" class="level3">
<h3 class="anchored" data-anchor-id="solid-state-emitters-nv-centers-quantum-dots">Solid-State Emitters (NV Centers, Quantum Dots)</h3>
<p><strong>Main sources:</strong> - Nuclear spin bath (the spin of nearby nuclei fluctuates) - Charge fluctuations - Phonons (vibrations of the crystal lattice)</p>
<p><strong>Typical <span class="math inline">\(T_2\)</span>:</strong> microseconds to milliseconds</p>
</section>
<section id="trapped-ions" class="level3">
<h3 class="anchored" data-anchor-id="trapped-ions">Trapped Ions</h3>
<p><strong>Main sources:</strong> - Magnetic field fluctuations - Electric field noise from the trap electrodes</p>
<p><strong>Typical <span class="math inline">\(T_2\)</span>:</strong> seconds to minutes (best of any platform!)</p>
<p>This is why trapped ions are leading candidates for quantum computers.</p>
<hr>
</section>
</section>
<section id="part-9-t1-and-t2-a-complete-noise-model" class="level2">
<h2 class="anchored" data-anchor-id="part-9-t1-and-t2-a-complete-noise-model">Part 9: T1 and T2 — A Complete Noise Model</h2>
<p>Decoherence comes in two flavors:</p>
<section id="t_2-dephasing-phase-noise" class="level3">
<h3 class="anchored" data-anchor-id="t_2-dephasing-phase-noise"><span class="math inline">\(T_2\)</span>: Dephasing (Phase Noise)</h3>
<p><strong>What it is:</strong> Random rotations around the z-axis (random phase kicks)</p>
<p><strong>Effect:</strong> Scrambles the relative phase between <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span></p>
<p><strong>Bloch sphere picture:</strong> States on the equator spread out azimuthally, eventually forming a ring, then averaging to the center.</p>
<p><strong>Mathematical model:</strong> Random <span class="math inline">\(R_z(\delta\phi)\)</span> rotations</p>
<p><span class="math display">\[\delta\phi \sim \mathcal{N}(0, \sigma^2) \quad \text{with} \quad \sigma \propto \sqrt{t/T_2}\]</span></p>
</section>
<section id="t_1-relaxation-population-decay" class="level3">
<h3 class="anchored" data-anchor-id="t_1-relaxation-population-decay"><span class="math inline">\(T_1\)</span>: Relaxation (Population Decay)</h3>
<p><strong>What it is:</strong> Energy exchange with the environment — the qubit spontaneously decays from <span class="math inline">\(|1\rangle\)</span> to <span class="math inline">\(|0\rangle\)</span></p>
<p><strong>Effect:</strong> The excited state population decays exponentially toward zero</p>
<p><strong>Bloch sphere picture:</strong> All states drift toward the north pole (ground state). A state at the south pole decays to the north pole; a state on the equator drifts upward.</p>
<p><strong>Mathematical model:</strong> With probability <span class="math inline">\(p = 1 - e^{-t/T_1}\)</span>, the qubit “collapses” to <span class="math inline">\(|0\rangle\)</span></p>
<p><strong>Physical origin:</strong> The qubit loses energy to the environment (emits a photon, creates a phonon, heats the bath, etc.)</p>
<p><strong>Important:</strong> Unlike <span class="math inline">\(T_2\)</span> dephasing, <span class="math inline">\(T_1\)</span> decay is <strong>not unitary</strong> — information is irreversibly lost to the environment. This is true dissipation.</p>
</section>
<section id="the-relationship" class="level3">
<h3 class="anchored" data-anchor-id="the-relationship">The Relationship</h3>
<p>In general: <span class="math inline">\(T_2 \leq 2T_1\)</span></p>
<p><strong>Why?</strong> <span class="math inline">\(T_1\)</span> processes also cause dephasing (if the population changes, the phase information is lost). But you can have pure dephasing (<span class="math inline">\(T_2\)</span> processes) without energy decay.</p>
<p>For many systems: <span class="math inline">\(T_2 \ll T_1\)</span>, meaning dephasing is the dominant problem.</p>
</section>
<section id="worked-example-maximum-interrogation-time" class="level3">
<h3 class="anchored" data-anchor-id="worked-example-maximum-interrogation-time">Worked Example: Maximum Interrogation Time</h3>
<p>A superconducting qubit has <span class="math inline">\(T_2 = 100\)</span> μs. You want to run a Ramsey experiment with at least 50% fringe contrast. What’s the maximum free evolution time?</p>
<p><strong>Solution:</strong> Fringe contrast decays as <span class="math inline">\(C = e^{-T/T_2}\)</span>.</p>
<p>Setting <span class="math inline">\(C = 0.5\)</span>: <span class="math display">\[e^{-T/T_2} = 0.5\]</span> <span class="math display">\[-T/T_2 = \ln(0.5) = -\ln(2)\]</span> <span class="math display">\[T = T_2 \ln(2) \approx 0.693 \times 100\,\mu\text{s} \approx 69\,\mu\text{s}\]</span></p>
<p>So you can wait about <span class="math inline">\(0.7 \times T_2\)</span> before losing half your signal.</p>
</section>
<section id="visualizing-decoherence-on-the-bloch-sphere" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-decoherence-on-the-bloch-sphere">Visualizing Decoherence on the Bloch Sphere</h3>
<p>The two types of decoherence look very different geometrically:</p>
<p><strong><span class="math inline">\(T_2\)</span> dephasing:</strong> 1. Start with a state on the equator (a superposition) 2. Random phase kicks rotate it around the z-axis 3. After many runs, the state “smears out” into a ring around the equator 4. When averaged, the ring collapses to a point at the center (completely mixed) 5. <strong>Result:</strong> Equatorial states lose coherence; poles are unaffected</p>
<p><strong><span class="math inline">\(T_1\)</span> relaxation:</strong> 1. Start with any state on the Bloch sphere 2. The state drifts toward the north pole (<span class="math inline">\(|0\rangle\)</span>) 3. States near the south pole decay fastest; states at the north pole don’t move 4. <strong>Result:</strong> All states eventually end up at <span class="math inline">\(|0\rangle\)</span></p>
</section>
<section id="summary-table" class="level3">
<h3 class="anchored" data-anchor-id="summary-table">Summary Table</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 24%">
<col style="width: 28%">
<col style="width: 14%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Process</th>
<th>Noise Type</th>
<th>Bloch Sphere</th>
<th>Model</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T_2\)</span> (dephasing)</td>
<td>Phase noise</td>
<td>Spread around z-axis</td>
<td>Random <span class="math inline">\(R_z\)</span> kicks</td>
<td>Fringes wash out toward 0.5</td>
</tr>
<tr class="even">
<td><span class="math inline">\(T_1\)</span> (relaxation)</td>
<td>Population decay</td>
<td>Drift toward north pole</td>
<td>Probabilistic collapse to <span class="math inline">\(\|0\rangle\)</span></td>
<td>Fringes wash out + bias toward <span class="math inline">\(\|0\rangle\)</span></td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="part-10-modeling-noisy-qubits" class="level2">
<h2 class="anchored" data-anchor-id="part-10-modeling-noisy-qubits">Part 10: Modeling Noisy Qubits</h2>
<p>You now have the tools to simulate realistic, noisy qubits!</p>
<section id="the-recipe" class="level3">
<h3 class="anchored" data-anchor-id="the-recipe">The Recipe</h3>
<ol type="1">
<li><p><strong>Ideal evolution:</strong> Apply your intended gates (<span class="math inline">\(R_x\)</span>, <span class="math inline">\(R_z\)</span>, etc.)</p></li>
<li><p><strong>Add <span class="math inline">\(T_2\)</span> noise:</strong> After periods of free evolution, apply random <span class="math inline">\(R_z(\delta\phi)\)</span> with <span class="math inline">\(\delta\phi \sim \mathcal{N}(0, t/T_2)\)</span></p></li>
<li><p><strong>Add <span class="math inline">\(T_1\)</span> noise:</strong> With probability <span class="math inline">\(p = 1 - e^{-t/T_1}\)</span>, collapse to <span class="math inline">\(|0\rangle\)</span></p></li>
<li><p><strong>Average over many runs:</strong> Quantum mechanics is probabilistic; noise makes it more so</p></li>
</ol>
</section>
<section id="qiskit-implementation" class="level3">
<h3 class="anchored" data-anchor-id="qiskit-implementation">Qiskit Implementation</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit <span class="im">import</span> QuantumCircuit</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.quantum_info <span class="im">import</span> Statevector</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> noisy_evolution(initial_state, gates, T1<span class="op">=</span>np.inf, T2<span class="op">=</span>np.inf, dt<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Simulate noisy qubit evolution.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    gates: list of (gate_name, parameter, duration) tuples</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">    T1, T2: coherence times</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">    dt: time step for noise application</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> initial_state.copy()</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> gate_name, param, duration <span class="kw">in</span> gates:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply ideal gate</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        qc <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> gate_name <span class="op">==</span> <span class="st">'rx'</span>:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            qc.rx(param, <span class="dv">0</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> gate_name <span class="op">==</span> <span class="st">'rz'</span>:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            qc.rz(param, <span class="dv">0</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... other gates</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> Statevector(qc).evolve(state)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply T2 noise (dephasing)</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> T2 <span class="op">&lt;</span> np.inf:</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            dephasing <span class="op">=</span> np.random.normal(<span class="dv">0</span>, np.sqrt(duration<span class="op">/</span>T2))</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>            qc_noise <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            qc_noise.rz(dephasing, <span class="dv">0</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> Statevector(qc_noise).evolve(state)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply T1 noise (relaxation) - simplified model</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> T1 <span class="op">&lt;</span> np.inf:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>            p_decay <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>duration<span class="op">/</span>T1)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> p_decay:</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> Statevector([<span class="dv">1</span>, <span class="dv">0</span>])  <span class="co"># Collapse to |0⟩</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="what-you-can-explore" class="level3">
<h3 class="anchored" data-anchor-id="what-you-can-explore">What You Can Explore</h3>
<p>With this model, you can investigate:</p>
<ol type="1">
<li><p><strong>How does fringe contrast decay with <span class="math inline">\(T\)</span>?</strong> Run Ramsey with increasing free evolution time.</p></li>
<li><p><strong>Which noise dominates?</strong> Compare pure <span class="math inline">\(T_2\)</span> noise vs pure <span class="math inline">\(T_1\)</span> noise.</p></li>
<li><p><strong>Can you “echo” away the noise?</strong> (Preview of dynamical decoupling — Chapter 4)</p></li>
</ol>
<hr>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<section id="the-ramsey-interferometer" class="level3">
<h3 class="anchored" data-anchor-id="the-ramsey-interferometer">The Ramsey Interferometer</h3>
<p><span class="math display">\[|0\rangle \xrightarrow{R_x(\pi/2)} \text{superposition} \xrightarrow{R_z(\phi)} \text{phase} \xrightarrow{R_x(\pi/2)} \text{population} \xrightarrow{\text{measure}} P_0 = \sin^2(\phi/2)\]</span></p>
</section>
<section id="applications" class="level3">
<h3 class="anchored" data-anchor-id="applications">Applications</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Application</th>
<th>What’s measured</th>
<th>Precision achieved</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Atomic clocks</td>
<td>Frequency</td>
<td><span class="math inline">\(10^{-18}\)</span> fractional</td>
</tr>
<tr class="even">
<td>GPS</td>
<td>Time/position</td>
<td>Meters globally</td>
</tr>
<tr class="odd">
<td>Magnetometry</td>
<td>Magnetic field</td>
<td>fT/<span class="math inline">\(\sqrt{\text{Hz}}\)</span></td>
</tr>
<tr class="even">
<td>Gravimetry</td>
<td>Gravitational acceleration</td>
<td><span class="math inline">\(10^{-9}\)</span> g</td>
</tr>
</tbody>
</table>
</section>
<section id="decoherence" class="level3">
<h3 class="anchored" data-anchor-id="decoherence">Decoherence</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 44%">
<col style="width: 21%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Physical origin</th>
<th>Effect</th>
<th>Model</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T_2\)</span> (dephasing)</td>
<td>Fluctuating fields</td>
<td>Phase scrambled</td>
<td>Random <span class="math inline">\(R_z\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(T_1\)</span> (relaxation)</td>
<td>Energy exchange</td>
<td>Population decays</td>
<td>Decay to <span class="math inline">\(\|0\rangle\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="the-fundamental-tradeoff" class="level3">
<h3 class="anchored" data-anchor-id="the-fundamental-tradeoff">The Fundamental Tradeoff</h3>
<ul>
<li><strong>Longer <span class="math inline">\(T\)</span></strong> → better sensitivity (<span class="math inline">\(\delta\omega \sim 1/T\)</span>)</li>
<li><strong>Longer <span class="math inline">\(T\)</span></strong> → more decoherence (contrast <span class="math inline">\(\sim e^{-T/T_2}\)</span>)</li>
</ul>
<p>The art of quantum sensing and computing is managing this tradeoff.</p>
</section>
<section id="looking-ahead-fighting-back-against-decoherence" class="level3">
<h3 class="anchored" data-anchor-id="looking-ahead-fighting-back-against-decoherence">Looking Ahead: Fighting Back Against Decoherence</h3>
<p>Is there any way to extend coherence beyond the natural <span class="math inline">\(T_2\)</span> limit?</p>
<p>Yes! If the noise is <em>slow</em> compared to our control pulses, we can “echo” it away. The idea: apply a π-pulse halfway through the free evolution. This flips the accumulated phase, so noise that accumulated in the first half gets cancelled by noise in the second half.</p>
<p>This technique is called <strong>dynamical decoupling</strong>, and it’s essential for real quantum computers. We’ll explore it in Chapter 4.</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2">
<h2 class="anchored" data-anchor-id="looking-ahead">Looking Ahead</h2>
<p>We’ve completed the single-qubit story: - States (Bloch sphere) - Gates (rotations) - Evolution (Hamiltonians) - Measurement (projection) - Noise (<span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span>)</p>
<p><strong>Next chapter:</strong> What happens when we have <strong>two qubits</strong>?</p>
<p>The answer is <strong>entanglement</strong> — correlations that have no classical explanation, and the resource that makes quantum computers powerful.</p>
<hr>
</section>
<section id="homework-2.7" class="level2">
<h2 class="anchored" data-anchor-id="homework-2.7">Homework 2.7</h2>
<section id="problem-1-ramsey-calculation-practice" class="level3">
<h3 class="anchored" data-anchor-id="problem-1-ramsey-calculation-practice">Problem 1: Ramsey Calculation Practice</h3>
<p>Work through the Ramsey sequence calculation yourself.</p>
<p><strong>(a)</strong> Write out <span class="math inline">\(R_x(\pi/2)\)</span> and <span class="math inline">\(R_z(\phi)\)</span> as explicit <span class="math inline">\(2\times 2\)</span> matrices.</p>
<p><strong>(b)</strong> Compute <span class="math inline">\(|\psi_1\rangle = R_x(\pi/2)|0\rangle\)</span>.</p>
<p><strong>(c)</strong> Compute <span class="math inline">\(|\psi_2\rangle = R_z(\phi)|\psi_1\rangle\)</span>.</p>
<p><strong>(d)</strong> Compute <span class="math inline">\(|\psi_3\rangle = R_x(\pi/2)|\psi_2\rangle\)</span>.</p>
<p><strong>(e)</strong> Show that <span class="math inline">\(P_0 = |\langle 0|\psi_3\rangle|^2 = \sin^2(\phi/2)\)</span>.</p>
<p><strong>(f)</strong> At what value of <span class="math inline">\(\phi\)</span> is <span class="math inline">\(P_0 = 1/2\)</span>? At what value is <span class="math inline">\(P_0 = 1\)</span>?</p>
<hr>
</section>
<section id="problem-2-atomic-clock-resolution" class="level3">
<h3 class="anchored" data-anchor-id="problem-2-atomic-clock-resolution">Problem 2: Atomic Clock Resolution</h3>
<p>A cesium fountain clock uses the hyperfine transition at <span class="math inline">\(\nu_0 = 9.192631770\)</span> GHz.</p>
<p><strong>(a)</strong> If the free evolution time is <span class="math inline">\(T = 0.5\)</span> s (typical for a fountain), what is the frequency resolution <span class="math inline">\(\delta\nu \sim 1/T\)</span>?</p>
<p><strong>(b)</strong> What is the fractional frequency resolution <span class="math inline">\(\delta\nu/\nu_0\)</span>?</p>
<p><strong>(c)</strong> An optical clock uses a transition at <span class="math inline">\(\nu_0 = 429\)</span> THz (strontium). For the same <span class="math inline">\(T = 0.5\)</span> s, what is the fractional resolution?</p>
<p><strong>(d)</strong> By what factor is the optical clock better than cesium (for the same <span class="math inline">\(T\)</span>)?</p>
<p><strong>(e)</strong> The best optical clocks achieve <span class="math inline">\(\delta\nu/\nu_0 \sim 10^{-18}\)</span>. How many seconds would it take for such a clock to gain or lose one second?</p>
<hr>
</section>
<section id="problem-3-gps-timing" class="level3">
<h3 class="anchored" data-anchor-id="problem-3-gps-timing">Problem 3: GPS Timing</h3>
<p><strong>(a)</strong> Light travels at <span class="math inline">\(c = 3 \times 10^8\)</span> m/s. How far does light travel in 1 nanosecond?</p>
<p><strong>(b)</strong> For GPS to achieve 1 meter position accuracy, what timing precision is required?</p>
<p><strong>(c)</strong> If a clock drifts by 1 μs per day, how much position error accumulates in one day?</p>
<p><strong>(d)</strong> GPS satellites orbit at ~20,000 km altitude. General relativity predicts their clocks run faster by <span class="math inline">\(\Delta f/f \approx gh/c^2\)</span> where <span class="math inline">\(g = 9.8\)</span> m/s² and <span class="math inline">\(h\)</span> is the altitude. Calculate this fractional shift.</p>
<p><strong>(e)</strong> Convert your answer to microseconds per day. Does this match the ~45 μs/day mentioned in lecture?</p>
<hr>
</section>
<section id="problem-4-magnetometry-sensitivity" class="level3">
<h3 class="anchored" data-anchor-id="problem-4-magnetometry-sensitivity">Problem 4: Magnetometry Sensitivity</h3>
<p>An electron spin magnetometer uses the Ramsey sequence to measure magnetic fields.</p>
<p><strong>(a)</strong> The electron gyromagnetic ratio is <span class="math inline">\(\gamma_e = 2\pi \times 28\)</span> GHz/T. In Earth’s magnetic field (<span class="math inline">\(B \approx 50\)</span> μT), what is the Larmor frequency?</p>
<p><strong>(b)</strong> With free evolution time <span class="math inline">\(T = 100\)</span> μs, what phase accumulates?</p>
<p><strong>(c)</strong> If you can resolve a phase change of <span class="math inline">\(\delta\phi = 0.01\)</span> rad, what is the minimum detectable field change <span class="math inline">\(\delta B\)</span>?</p>
<p><strong>(d)</strong> To improve sensitivity by a factor of 10, how should you change <span class="math inline">\(T\)</span>?</p>
<p><strong>(e)</strong> What ultimately limits how large you can make <span class="math inline">\(T\)</span>?</p>
<hr>
</section>
<section id="problem-5-ramsey-fringes-qiskit" class="level3">
<h3 class="anchored" data-anchor-id="problem-5-ramsey-fringes-qiskit">Problem 5: Ramsey Fringes (Qiskit)</h3>
<p><strong>(a)</strong> Write a Qiskit function that implements the Ramsey sequence and returns <span class="math inline">\(P_0\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey(phi):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Ramsey sequence: Rx(π/2) - Rz(φ) - Rx(π/2)"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Your code here</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(b)</strong> Plot <span class="math inline">\(P_0\)</span> vs <span class="math inline">\(\phi\)</span> for <span class="math inline">\(\phi \in [0, 4\pi]\)</span>. Verify it matches <span class="math inline">\(\sin^2(\phi/2)\)</span>.</p>
<p><strong>(c)</strong> Modify your function to use <span class="math inline">\(R_y(\pi/2)\)</span> pulses instead of <span class="math inline">\(R_x(\pi/2)\)</span>. How does the result change?</p>
<p><strong>(d)</strong> What if the two pulses have different axes — e.g., first pulse is <span class="math inline">\(R_x(\pi/2)\)</span>, second is <span class="math inline">\(R_y(\pi/2)\)</span>? Plot and explain.</p>
<hr>
</section>
<section id="problem-6-simulating-dephasing-qiskit" class="level3">
<h3 class="anchored" data-anchor-id="problem-6-simulating-dephasing-qiskit">Problem 6: Simulating Dephasing (Qiskit)</h3>
<p>This problem explores how noise destroys quantum coherence.</p>
<p><strong>(a)</strong> Modify your Ramsey function to add random phase noise:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_noisy(phi, noise_strength):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Ramsey with dephasing: add random phase kick."""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    qc <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    random_phase <span class="op">=</span> np.random.normal(<span class="dv">0</span>, noise_strength)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    qc.rz(phi <span class="op">+</span> random_phase, <span class="dv">0</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Statevector(qc).probabilities()[<span class="dv">0</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(b)</strong> For a single value of <span class="math inline">\(\phi = \pi\)</span>, run <code>ramsey_noisy(π, 0.5)</code> 20 times and print the results. What do you observe?</p>
<p><strong>(c)</strong> Write a function that averages over many trials:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_averaged(phi, noise_strength, n_trials<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean([ramsey_noisy(phi, noise_strength) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials)])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(d)</strong> Plot Ramsey fringes (<span class="math inline">\(P_0\)</span> vs <span class="math inline">\(\phi\)</span>) for <code>noise_strength = 0, 0.3, 0.7, 1.5</code> on the same graph. Use <code>n_trials=200</code> for smooth curves.</p>
<p><strong>(e)</strong> Define the <strong>fringe contrast</strong> as <span class="math inline">\(C = (P_{0,\max} - P_{0,\min})\)</span>. Estimate <span class="math inline">\(C\)</span> for each noise strength from your plots.</p>
<p><strong>(f)</strong> Explain in your own words: why do the fringes “wash out” with increasing noise?</p>
<hr>
</section>
<section id="problem-7-t1-vs-t2-noise" class="level3">
<h3 class="anchored" data-anchor-id="problem-7-t1-vs-t2-noise">Problem 7: T1 vs T2 Noise</h3>
<p>In this problem, you’ll compare the two types of decoherence.</p>
<p><strong>(a)</strong> <strong>T2 noise (dephasing):</strong> Implement a Ramsey sequence where, during free evolution, you apply a random <span class="math inline">\(R_z\)</span> rotation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_T2_noise(phi, T2_noise):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""T2 (dephasing) noise: random phase kicks."""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    qc <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    qc.rz(phi, <span class="dv">0</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    qc.rz(np.random.normal(<span class="dv">0</span>, T2_noise), <span class="dv">0</span>)  <span class="co"># Random dephasing</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Statevector(qc).probabilities()[<span class="dv">0</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(b)</strong> <strong>T1 noise (relaxation):</strong> Implement a version where, with some probability, the qubit decays to <span class="math inline">\(|0\rangle\)</span> during free evolution. If decay happens, the qubit is in <span class="math inline">\(|0\rangle\)</span> when the second pulse arrives:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_T1_noise(phi, p_decay):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""T1 (relaxation) noise: probabilistic decay to |0⟩."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if decay happens during free evolution</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> p_decay:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Qubit decayed to |0⟩, then second π/2 pulse is applied</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        qc <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)  <span class="co"># Second pulse acts on |0⟩</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> Statevector(qc)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state.probabilities()[<span class="dv">0</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># No decay: normal Ramsey sequence</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        qc <span class="op">=</span> QuantumCircuit(<span class="dv">1</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        qc.rz(phi, <span class="dv">0</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        qc.rx(np.pi<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Statevector(qc).probabilities()[<span class="dv">0</span>]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(c)</strong> Write averaging functions for both:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_T2_averaged(phi, T2_noise, n_trials<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean([ramsey_T2_noise(phi, T2_noise) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials)])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ramsey_T1_averaged(phi, p_decay, n_trials<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean([ramsey_T1_noise(phi, p_decay) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_trials)])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>(d)</strong> Plot averaged Ramsey fringes (<span class="math inline">\(P_0\)</span> vs <span class="math inline">\(\phi\)</span>) for: - No noise (ideal Ramsey) - Pure T2 noise (<code>T2_noise = 0.7</code>, <code>p_decay = 0</code>) - Pure T1 noise (<code>T2_noise = 0</code>, <code>p_decay = 0.3</code>)</p>
<p>Use <code>n_trials=200</code> and <span class="math inline">\(\phi \in [0, 4\pi]\)</span>.</p>
<p><strong>(e)</strong> Describe qualitatively: how do the two types of noise affect the fringes differently?</p>
<p><em>Hint:</em> T2 noise should reduce the contrast (fringes wash out toward <span class="math inline">\(P_0 = 0.5\)</span>). T1 noise should also reduce contrast, but bias the average toward… what value? Think about what happens when decay occurs.</p>
<hr>
</section>
<section id="problem-8-the-coherence-time-tradeoff" class="level3">
<h3 class="anchored" data-anchor-id="problem-8-the-coherence-time-tradeoff">Problem 8: The Coherence Time Tradeoff</h3>
<p>Explore the fundamental tradeoff between sensitivity and decoherence.</p>
<p><strong>(a)</strong> For a Ramsey magnetometer, the signal (ability to detect a small field change) depends on: - The accumulated phase: <span class="math inline">\(\phi = \gamma B T\)</span> (larger <span class="math inline">\(T\)</span> → larger <span class="math inline">\(\phi\)</span>) - The fringe contrast: <span class="math inline">\(C \approx e^{-T/T_2}\)</span> (larger <span class="math inline">\(T\)</span> → smaller <span class="math inline">\(C\)</span>)</p>
<p>The “figure of merit” for sensitivity is roughly <span class="math inline">\(F = \phi \cdot C = \gamma B T \cdot e^{-T/T_2}\)</span>.</p>
<p><strong>(b)</strong> Take the derivative <span class="math inline">\(dF/dT\)</span> and set it to zero to find the optimal measurement time <span class="math inline">\(T_{\text{opt}}\)</span>.</p>
<p><strong>(c)</strong> For a system with <span class="math inline">\(T_2 = 100\)</span> μs, what is <span class="math inline">\(T_{\text{opt}}\)</span>?</p>
<p><strong>(d)</strong> What fraction of the maximum contrast remains at <span class="math inline">\(T_{\text{opt}}\)</span>?</p>
<p><strong>(e)</strong> Explain why the optimal time is <span class="math inline">\(T_2\)</span>, not infinity or zero.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>