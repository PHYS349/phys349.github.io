<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lecture</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="01_03_lecture_files/libs/clipboard/clipboard.min.js"></script>
<script src="01_03_lecture_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="01_03_lecture_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="01_03_lecture_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="01_03_lecture_files/libs/quarto-html/popper.min.js"></script>
<script src="01_03_lecture_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="01_03_lecture_files/libs/quarto-html/anchor.min.js"></script>
<link href="01_03_lecture_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="01_03_lecture_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="01_03_lecture_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="01_03_lecture_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="01_03_lecture_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="lecture-3-what-makes-quantum-hard" class="level1">
<h1>Lecture 3: What Makes Quantum Hard?</h1>
<section id="from-seating-arrangements-to-quantum-spins" class="level2">
<h2 class="anchored" data-anchor-id="from-seating-arrangements-to-quantum-spins">From seating arrangements to quantum spins</h2>
<p>Last lecture, you wrestled with the wedding seating problem. You discovered that even with just 30 guests, brute-force search was impossible—there were simply too many arrangements to check.</p>
<p>Today we’ll see that this problem was actually a physics problem in disguise. And understanding why it was hard will lead us directly to the core idea of quantum computing. <!--  --> ### The Explosion of Configurations</p>
<p>Recall the wedding problem: you had <span class="math inline">\(N\)</span> guests and needed to find the seating arrangement that minimized drama. The number of possible arrangements was: <span class="math display">\[
N! = N \times (N-1) \times (N-2) \times \cdots \times 1
\]</span></p>
<p>For 30 guests, that’s about <span class="math inline">\(10^{32}\)</span> possibilities—far more than any computer could ever search.</p>
<p>Now let’s consider a simpler counting problem. Imagine a row of spins, each pointing either up (<span class="math inline">\(\uparrow\)</span>) or down (<span class="math inline">\(\downarrow\)</span>):</p>
<p><span class="math display">\[
\uparrow \quad \downarrow \quad \uparrow \quad \uparrow \quad \downarrow \quad \downarrow \quad \uparrow \quad \downarrow \quad \uparrow \quad \downarrow
\]</span></p>
<p>We can encode this as a list of numbers: <span class="math inline">\(s_i = +1\)</span> for up, <span class="math inline">\(s_i = -1\)</span> for down: <span class="math display">\[
s = [+1, -1, +1, +1, -1, -1, +1, -1, +1, -1]
\]</span></p>
<p>How many such configurations exist for <span class="math inline">\(N\)</span> spins?</p>
<p>Each spin has 2 choices, and the choices are independent: <span class="math display">\[
\underbrace{2 \times 2 \times 2 \times \cdots \times 2}_{N \text{ times}} = 2^N
\]</span></p>
<p>This is exponential growth:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(N\)</span></th>
<th><span class="math inline">\(2^N\)</span></th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>1,024</td>
<td>Easy</td>
</tr>
<tr class="even">
<td>20</td>
<td>~1 million</td>
<td>Still manageable</td>
</tr>
<tr class="odd">
<td>30</td>
<td>~1 billion</td>
<td>Getting hard</td>
</tr>
<tr class="even">
<td>50</td>
<td>~<span class="math inline">\(10^{15}\)</span></td>
<td>Exceeds all computers</td>
</tr>
<tr class="odd">
<td>300</td>
<td>~<span class="math inline">\(10^{90}\)</span></td>
<td>More than atoms in universe</td>
</tr>
</tbody>
</table>
<p>The wedding problem (<span class="math inline">\(N!\)</span>) is even worse than <span class="math inline">\(2^N\)</span>, but both are intractable for large <span class="math inline">\(N\)</span>. No classical algorithm can search through all possibilities.</p>
<p>This is the first key insight:</p>
<blockquote class="blockquote">
<p><strong>The number of configurations grows exponentially with the number of particles.</strong></p>
</blockquote>
<p>In the wedding problem, you had a “drama matrix” <span class="math inline">\(D_{ij}\)</span> that told you how much two guests disliked sitting together. You minimized the total drama.</p>
<p>Physics has exactly the same structure—but we call the cost function energy, and we call the drama matrix the <strong>Hamiltonian</strong>.</p>
<section id="why-energy" class="level3">
<h3 class="anchored" data-anchor-id="why-energy">Why Energy?</h3>
<p>Nature has a deep tendency to minimize energy:</p>
<p>- Hot coffee cools down (energy flows to the environment) - Balls roll downhill (gravitational potential energy decreases)</p>
<p>- Crystals form from liquid (atoms find low-energy arrangements)</p>
<p>- Magnets align with external fields (magnetic energy decreases)</p>
<p>When a system reaches its lowest possible energy, we call that the <strong>ground state</strong>.</p>
<p>Finding the ground state of a physical system is exactly like finding the optimal seating arrangement: you’re searching for the configuration that minimizes a cost function.</p>
</section>
<section id="the-hamiltonian" class="level3">
<h3 class="anchored" data-anchor-id="the-hamiltonian">The Hamiltonian</h3>
<p>In physics, the cost function is called the <strong>Hamiltonian</strong>, denoted <span class="math inline">\(H\)</span>. It’s the “energy operator”—given a configuration, it tells you the energy.</p>
<p>For spins, we’ll build up the Hamiltonian in two pieces.</p>
</section>
</section>
<section id="spins-in-a-magnetic-field" class="level2">
<h2 class="anchored" data-anchor-id="spins-in-a-magnetic-field">Spins in a Magnetic Field</h2>
<p>Let’s start with the simplest case: a single spin in an external magnetic field <span class="math inline">\(B\)</span>.</p>
<p>A spin is like a tiny compass needle. It wants to align with the magnetic field, because that’s the lowest-energy configuration.</p>
<p>We write the energy as: <span class="math display">\[
H = -B \, s
\]</span></p>
<p>where <span class="math inline">\(s = +1\)</span> (up) or <span class="math inline">\(s = -1\)</span> (down).</p>
<p>Let’s check the signs. If <span class="math inline">\(B &gt; 0\)</span> (field pointing up): - Spin up (<span class="math inline">\(s = +1\)</span>): <span class="math inline">\(H = -B(+1) = -B\)</span> (negative energy, <strong>low</strong>) - Spin down (<span class="math inline">\(s = -1\)</span>): <span class="math inline">\(H = -B(-1) = +B\)</span> (positive energy, <strong>high</strong>)</p>
<p>The spin pointing <em>with</em> the field has lower energy.</p>
<p>For <span class="math inline">\(N\)</span> spins, each feeling the same field <span class="math inline">\(B\)</span>: <span class="math display">\[
H = -B \sum_{i=1}^{N} s_i
\]</span></p>
<p>The ground state is obvious: all spins point up (if <span class="math inline">\(B &gt; 0\)</span>), giving energy <span class="math inline">\(H = -NB\)</span>.</p>
<p>This is too easy. The interesting physics comes when spins interact with <em>each other</em>.</p>
</section>
<section id="spin-spin-interactions-the-ising-model" class="level2">
<h2 class="anchored" data-anchor-id="spin-spin-interactions-the-ising-model">Spin-Spin Interactions: The Ising Model</h2>
<p>Real materials aren’t just spins in a field—neighboring spins also interact with each other. An electron’s spin on one atom can influence the spin on a neighboring atom.</p>
<p>We model this with the <strong>Ising model</strong>, one of the most important models in physics. For a 1D chain with nearest-neighbor interactions: <span class="math display">\[
H = -J \sum_{i=1}^{N-1} s_i s_{i+1} - B \sum_{i=1}^{N} s_i
\]</span></p>
<p>Let’s unpack each term.</p>
<section id="the-interaction-term" class="level3">
<h3 class="anchored" data-anchor-id="the-interaction-term">The Interaction Term</h3>
<p><span class="math display">\[
-J \sum_{i=1}^{N-1} s_i s_{i+1}
\]</span></p>
<p>This sums over adjacent pairs: <span class="math inline">\((s_1, s_2)\)</span>, <span class="math inline">\((s_2, s_3)\)</span>, …, <span class="math inline">\((s_{N-1}, s_N)\)</span>.</p>
<p>The coupling constant <span class="math inline">\(J\)</span> describes the interaction strength. The product <span class="math inline">\(s_i s_{i+1}\)</span> is: - <span class="math inline">\(+1\)</span> if spins are aligned (<span class="math inline">\(\uparrow\uparrow\)</span> or <span class="math inline">\(\downarrow\downarrow\)</span>) - <span class="math inline">\(-1\)</span> if spins are anti-aligned (<span class="math inline">\(\uparrow\downarrow\)</span> or <span class="math inline">\(\downarrow\uparrow\)</span>)</p>
<p>What about the sign of <span class="math inline">\(J\)</span>?</p>
<p><strong>If</strong> <span class="math inline">\(J &gt; 0\)</span> (ferromagnetic): - Aligned spins: <span class="math inline">\(H = -J(+1) = -J\)</span> (low energy ✓) - Anti-aligned spins: <span class="math inline">\(H = -J(-1) = +J\)</span> (high energy) - Spins <strong>want to align</strong></p>
<p><strong>If</strong> <span class="math inline">\(J &lt; 0\)</span> (antiferromagnetic): - Aligned spins: <span class="math inline">\(H = -J(+1) = +|J|\)</span> (high energy) - Anti-aligned spins: <span class="math inline">\(H = -J(-1) = -|J|\)</span> (low energy ✓) - Spins <strong>want to anti-align</strong></p>
<p>This is exactly the drama matrix from the wedding problem! Positive <span class="math inline">\(J\)</span> means the spins “get along” (want to be the same); negative <span class="math inline">\(J\)</span> means they “fight” (want to be different).</p>
</section>
<section id="visualizing-the-interactions" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-the-interactions">Visualizing the Interactions</h3>
<p>For a 1D chain, we can visualize the coupling:</p>
<p><span class="math display">\[
\uparrow \quad \downarrow \quad \uparrow \quad \downarrow \quad \uparrow
\]</span> <span class="math display">\[
\underset{J}{\smile} \quad \underset{J}{\smile} \quad \underset{J}{\smile} \quad \underset{J}{\smile}
\]</span></p>
<p>If we wanted to write this as a matrix (like the drama matrix), it would have a simple structure—only the entries just off the diagonal are nonzero:</p>
<p><span class="math display">\[
J_{\text{matrix}} = \begin{pmatrix}
0 &amp; J &amp; 0 &amp; 0 &amp; 0 \\
J &amp; 0 &amp; J &amp; 0 &amp; 0 \\
0 &amp; J &amp; 0 &amp; J &amp; 0 \\
0 &amp; 0 &amp; J &amp; 0 &amp; J \\
0 &amp; 0 &amp; 0 &amp; J &amp; 0
\end{pmatrix}
\]</span></p>
<p>Compare this to the drama matrix from the wedding problem—same structure, different physical interpretation.</p>
</section>
<section id="the-competition" class="level3">
<h3 class="anchored" data-anchor-id="the-competition">The Competition</h3>
<p>The interesting physics happens when the two terms compete.</p>
<p>Consider an antiferromagnet (<span class="math inline">\(J &lt; 0\)</span>) in an external field (<span class="math inline">\(B &gt; 0\)</span>): - The interaction term wants neighboring spins to anti-align: <span class="math inline">\(\uparrow\downarrow\uparrow\downarrow\uparrow\downarrow\)</span> - The field term wants all spins to point up: <span class="math inline">\(\uparrow\uparrow\uparrow\uparrow\uparrow\uparrow\)</span></p>
<p>Which wins? It depends on the relative strength of <span class="math inline">\(|J|\)</span> versus <span class="math inline">\(B\)</span>.</p>
<ul>
<li>If <span class="math inline">\(|J| \gg B\)</span>: interactions dominate → alternating pattern</li>
<li>If <span class="math inline">\(B \gg |J|\)</span>: field dominates → all spins up</li>
<li>If <span class="math inline">\(|J| \approx B\)</span>: <strong>frustration</strong>—the system can’t satisfy both constraints</li>
</ul>
<p>The crossover between these regimes is called a <strong>phase transition</strong>. You’ll explore this in the homework.</p>
</section>
</section>
<section id="how-would-you-solve-this-classically" class="level2">
<h2 class="anchored" data-anchor-id="how-would-you-solve-this-classically">How Would You Solve This Classically?</h2>
<p>You now have a well-defined optimization problem:</p>
<blockquote class="blockquote">
<p>Given <span class="math inline">\(J\)</span> and <span class="math inline">\(B\)</span>, find the spin configuration <span class="math inline">\(s = [s_1, s_2, \ldots, s_N]\)</span> that minimizes <span class="math inline">\(H(s)\)</span>.</p>
</blockquote>
<p>For small <span class="math inline">\(N\)</span>, you can try all <span class="math inline">\(2^N\)</span> configurations. But for <span class="math inline">\(N = 50\)</span>, that’s <span class="math inline">\(10^{15}\)</span> configurations—impossible.</p>
<p>Is there a smarter approach?</p>
<section id="natures-strategy-simulated-annealing" class="level3">
<h3 class="anchored" data-anchor-id="natures-strategy-simulated-annealing">Nature’s Strategy: Simulated Annealing</h3>
<p>Think about how nature actually solves this problem. When you cool a material slowly, the atoms don’t instantly jump to the ground state. Instead:</p>
<ol type="1">
<li>At high temperature, atoms jiggle around randomly</li>
<li>As temperature drops, atoms start settling into lower-energy arrangements</li>
<li>At very low temperature, the system freezes into (hopefully) the ground state</li>
</ol>
<p>This process is called <strong>annealing</strong>, and we can simulate it on a computer.</p>
</section>
<section id="the-simulated-annealing-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-simulated-annealing-algorithm">The Simulated Annealing Algorithm</h3>
<p><strong>Step 1: Start hot</strong></p>
<p>Initialize with a random spin configuration: <span class="math display">\[
s = [+1, -1, +1, +1, -1, -1, +1, -1, +1, -1]
\]</span></p>
<p>At high temperature, any configuration is acceptable.</p>
<p><strong>Step 2: Propose a change</strong></p>
<p>Pick a random spin and flip it. Calculate the energy change: <span class="math display">\[
\Delta E = E_{\text{new}} - E_{\text{old}}
\]</span></p>
<p><strong>Step 3: Accept or reject</strong></p>
<p>Here’s the key insight from statistical mechanics:</p>
<ul>
<li>If <span class="math inline">\(\Delta E &lt; 0\)</span> (energy decreases): <strong>always accept</strong> the flip</li>
<li>If <span class="math inline">\(\Delta E &gt; 0\)</span> (energy increases): <strong>accept with probability</strong> <span class="math inline">\(e^{-\Delta E / T}\)</span></li>
</ul>
<p>At high temperature <span class="math inline">\(T\)</span>, the probability <span class="math inline">\(e^{-\Delta E / T}\)</span> is close to 1, so we accept almost anything—the system explores freely.</p>
<p>At low temperature <span class="math inline">\(T\)</span>, the probability <span class="math inline">\(e^{-\Delta E / T}\)</span> is close to 0, so we only accept downhill moves—the system gets trapped in low-energy states.</p>
<p><strong>Step 4: Cool down and repeat</strong></p>
<p>Gradually lower the temperature while repeating steps 2-3. The system will (hopefully) settle into a low-energy configuration.</p>
<pre><code>Algorithm: Simulated Annealing
─────────────────────────────
1. Initialize random configuration s
2. Set initial temperature T = T_high
3. While T &gt; T_low:
   a. Pick random spin i
   b. Compute ΔE if we flip spin i
   c. If ΔE &lt; 0: flip the spin
      Else: flip with probability exp(-ΔE/T)
   d. Lower T slightly (e.g., T → 0.99 × T)
4. Return final configuration</code></pre>
<p>This is a <strong>heuristic</strong>—it doesn’t guarantee the global minimum, but it often finds good solutions. It’s inspired directly by how nature finds ground states.</p>
</section>
<section id="the-limitation" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation">The Limitation</h3>
<p>Simulated annealing is clever, but it’s still classical. It explores configurations one at a time, making local changes and hoping to find the global minimum.</p>
<p>For some problems, this works well. For others, the energy landscape has many local minima, and the algorithm gets stuck.</p>
<p>Is there a fundamentally different approach?</p>
<p>What if, instead of exploring configurations one at a time, we could explore <em>all configurations simultaneously</em>?</p>
<p>This is exactly what quantum mechanics allows.</p>
<hr>
</section>
</section>
<section id="nature-can-explore-all-configurations-at-the-same-time" class="level2">
<h2 class="anchored" data-anchor-id="nature-can-explore-all-configurations-at-the-same-time">Nature Can Explore All Configurations at the Same Time</h2>
<p>Here is the key idea that separates quantum from classical:</p>
<blockquote class="blockquote">
<p><strong>In quantum mechanics, a system doesn’t have to be in one configuration—it can be in a superposition of all configurations simultaneously.</strong></p>
</blockquote>
<p>This isn’t just uncertainty about which configuration the system is in. The system genuinely <em>is</em> in all configurations at once, with each configuration carrying a complex amplitude that determines how it contributes to the whole.</p>
<p>Let’s build up to this idea step by step.</p>
<section id="from-classical-position-to-quantum-wavefunction" class="level3">
<h3 class="anchored" data-anchor-id="from-classical-position-to-quantum-wavefunction">From Classical Position to Quantum Wavefunction</h3>
<p>Think about a single particle moving in space.</p>
<p><strong>Classical picture:</strong> At any moment, the particle has a definite position <span class="math inline">\(x(t)\)</span>. We might not know exactly where it is, but it’s definitely <em>somewhere</em>.</p>
<p><strong>Quantum picture:</strong> The particle is described by a <strong>wavefunction</strong> <span class="math inline">\(\psi(x)\)</span>—a complex number assigned to every possible position <span class="math inline">\(x\)</span>.</p>
<pre><code>Classical:     •  ← particle is HERE
               x

Quantum:      ~~~•~~~  ← amplitude spread over positions
              ψ(x)</code></pre>
<p>The wavefunction tells us: if we were to measure the particle’s position, how likely are we to find it at each location? But before measurement, the particle doesn’t have a definite position—it exists as a wave spread across all possibilities.</p>
<p>Let’s give this a name: each possible position <span class="math inline">\(x\)</span> is a <strong>configuration</strong>. The wavefunction assigns a complex amplitude to every configuration.</p>
</section>
<section id="complex-amplitudes-and-interference" class="level3">
<h3 class="anchored" data-anchor-id="complex-amplitudes-and-interference">Complex Amplitudes and Interference</h3>
<p>What is a “complex amplitude”? It’s a complex number <span class="math inline">\(c = a + bi\)</span>, which has two parts: - <strong>Magnitude</strong> <span class="math inline">\(|c| = \sqrt{a^2 + b^2}\)</span>: how “much” of that configuration - <strong>Phase</strong> <span class="math inline">\(\phi\)</span>: the “angle” of the complex number (from <span class="math inline">\(0\)</span> to <span class="math inline">\(2\pi\)</span>)</p>
<p>You can visualize a complex amplitude as a little arrow (or clock hand): the length is the magnitude, and the direction is the phase.</p>
<pre><code>Complex plane:

        Im
        ↑
        |   ↗ c = a + bi
        |  /
        | / |c| = magnitude
        |/θ        
    ----+------ Re
        |    θ = phase</code></pre>
<p><strong>Why does phase matter?</strong> Because of interference. When two amplitudes combine:</p>
<pre><code>CONSTRUCTIVE (same phase):       DESTRUCTIVE (opposite phase):

    ↗           ↗                    ↗           ↙
     \         /                      \         /
      \       /                        \       /
       ↘     ↙                          ↘     ↙
         ↓                                •
    BIG amplitude                    ZERO amplitude
    (high probability)               (low probability)</code></pre>
<p>This is the heart of quantum mechanics: amplitudes with the same phase add up (constructive interference), while amplitudes with opposite phases cancel (destructive interference).</p>
<p>We’ll explore complex numbers more next week. For now, just remember: each configuration gets a magnitude <em>and</em> a phase, and the phase determines how configurations interfere.</p>
</section>
<section id="simplifying-two-positions" class="level3">
<h3 class="anchored" data-anchor-id="simplifying-two-positions">Simplifying: Two Positions</h3>
<p>Continuous position space is complicated. Let’s simplify to the extreme: imagine a particle that can only be in <strong>two positions</strong>, Left or Right.</p>
<p><strong>Classical:</strong> The particle is either at L or at R. Even if we’re uncertain, it’s definitely one or the other.</p>
<p><strong>Quantum:</strong> The particle has a complex amplitude for each position: <span class="math display">\[
|\psi\rangle = c_L |L\rangle + c_R |R\rangle
\]</span></p>
<p>where: - <span class="math inline">\(c_L\)</span> is the amplitude to be on the left - <span class="math inline">\(c_R\)</span> is the amplitude to be on the right - <span class="math inline">\(|L\rangle\)</span> and <span class="math inline">\(|R\rangle\)</span> are the two configurations</p>
<p>This is called a <strong>superposition</strong>. The particle isn’t at L <em>or</em> R—it’s in both configurations simultaneously, with amplitudes <span class="math inline">\(c_L\)</span> and <span class="math inline">\(c_R\)</span>.</p>
</section>
<section id="normalization" class="level3">
<h3 class="anchored" data-anchor-id="normalization">Normalization</h3>
<p>There’s one constraint: the total probability must equal 1. Since probability is the magnitude squared: <span class="math display">\[
|c_L|^2 + |c_R|^2 = 1
\]</span></p>
<p>This is called <strong>normalization</strong>. It guarantees that if we measure the position, we’ll definitely find the particle somewhere.</p>
</section>
<section id="a-physical-two-configuration-system-spin" class="level3">
<h3 class="anchored" data-anchor-id="a-physical-two-configuration-system-spin">A Physical Two-Configuration System: Spin</h3>
<p>There’s a real physical system that behaves exactly this way: the <strong>spin</strong> of an electron.</p>
<p>When you measure an electron’s spin along any axis (say, the <span class="math inline">\(z\)</span>-axis), you only ever get one of two results: “up” (<span class="math inline">\(\uparrow\)</span>) or “down” (<span class="math inline">\(\downarrow\)</span>). There’s no in-between.</p>
<p>But before measurement, the spin can be in a superposition: <span class="math display">\[
|\psi\rangle = c_\uparrow |\uparrow\rangle + c_\downarrow |\downarrow\rangle
\]</span></p>
<p>This is mathematically identical to the two-position system: - Two configurations: <span class="math inline">\(|\uparrow\rangle\)</span> and <span class="math inline">\(|\downarrow\rangle\)</span> - Two complex amplitudes: <span class="math inline">\(c_\uparrow\)</span> and <span class="math inline">\(c_\downarrow\)</span> - Normalization: <span class="math inline">\(|c_\uparrow|^2 + |c_\downarrow|^2 = 1\)</span></p>
<p>We can represent the quantum state as a <strong>vector</strong>: <span class="math display">\[
|\psi\rangle = \begin{pmatrix} c_\uparrow \\ c_\downarrow \end{pmatrix}
\]</span></p>
<p>This is called the <strong>state vector</strong>. For a two-configuration system, it’s a vector in <span class="math inline">\(\mathbb{C}^2\)</span> (two-dimensional complex space).</p>
</section>
<section id="time-evolution-matrices" class="level3">
<h3 class="anchored" data-anchor-id="time-evolution-matrices">Time Evolution: Matrices</h3>
<p>How does a quantum state change in time?</p>
<p>Recall classical mechanics: position updates via velocity. <span class="math display">\[
x(t + \Delta t) = x(t) + v \cdot \Delta t
\]</span></p>
<p>In quantum mechanics, the state vector updates via <strong>matrix multiplication</strong>: <span class="math display">\[
\begin{pmatrix} c_\uparrow(t+\Delta t) \\ c_\downarrow(t+\Delta t) \end{pmatrix}
=
\begin{pmatrix} U_{00} &amp; U_{01} \\ U_{10} &amp; U_{11} \end{pmatrix}
\begin{pmatrix} c_\uparrow(t) \\ c_\downarrow(t) \end{pmatrix}
\]</span></p>
<p>The matrix <span class="math inline">\(U\)</span> is called a <strong>unitary matrix</strong>. “Unitary” means it preserves normalization—if <span class="math inline">\(|c_\uparrow|^2 + |c_\downarrow|^2 = 1\)</span> before evolution, it’s still 1 afterward. (You’ll prove this in the homework.)</p>
<p><strong>Computational cost:</strong> For a 2×2 matrix times a 2-vector, we need about <span class="math inline">\(2^2 = 4\)</span> multiplications per time step. Easy!</p>
</section>
<section id="two-spins-where-it-gets-interesting" class="level3">
<h3 class="anchored" data-anchor-id="two-spins-where-it-gets-interesting">Two Spins: Where It Gets Interesting</h3>
<p>Now let’s add a second spin.</p>
<p><strong>Classical:</strong> With two spins, there are four possible configurations: <span class="math display">\[
\uparrow\uparrow, \quad \uparrow\downarrow, \quad \downarrow\uparrow, \quad \downarrow\downarrow
\]</span></p>
<p>The system is in exactly one of these at any moment.</p>
<p><strong>Quantum:</strong> The system can be in a superposition of <em>all four</em> configurations: <span class="math display">\[
|\psi\rangle = c_{\uparrow\uparrow}|\uparrow\uparrow\rangle + c_{\uparrow\downarrow}|\uparrow\downarrow\rangle + c_{\downarrow\uparrow}|\downarrow\uparrow\rangle + c_{\downarrow\downarrow}|\downarrow\downarrow\rangle
\]</span></p>
<p>Each configuration gets its own complex amplitude—its own magnitude and phase.</p>
<p><strong>A note on notation:</strong> Here the subscripts like <span class="math inline">\(\uparrow\uparrow\)</span> are labels for configurations. This is different from the classical Ising model where we used <span class="math inline">\(s_i = \pm 1\)</span> as numerical values. In the quantum case, <span class="math inline">\(c_{\uparrow\uparrow}\)</span> is a complex number (the amplitude), while <span class="math inline">\(|\uparrow\uparrow \rangle\)</span> is a basis state (the configuration).</p>
<p>The state vector now has <strong>4 components</strong>: <span class="math display">\[
|\psi\rangle = \begin{pmatrix} c_{\uparrow\uparrow} \\ c_{\uparrow\downarrow} \\ c_{\downarrow\uparrow} \\ c_{\downarrow\downarrow} \end{pmatrix}
\]</span></p>
<p>And time evolution requires a <strong>4×4 matrix</strong>: <span class="math display">\[
|\psi(t+\Delta t)\rangle = U \, |\psi(t)\rangle
\]</span></p>
<p>where <span class="math inline">\(U\)</span> is now a <span class="math inline">\(4 \times 4\)</span> unitary matrix.</p>
<p><strong>Computational cost:</strong> <span class="math inline">\(4 \times 4 = 16\)</span> operations per time step.</p>
</section>
<section id="a-glimpse-of-entanglement" class="level3">
<h3 class="anchored" data-anchor-id="a-glimpse-of-entanglement">A Glimpse of Entanglement</h3>
<p>Here’s something remarkable. Consider the two-spin state: <span class="math display">\[
|\psi\rangle = \frac{1}{\sqrt{2}}|\uparrow\uparrow\rangle + \frac{1}{\sqrt{2}}|\downarrow\downarrow\rangle
\]</span></p>
<p>Can we write this as “spin 1 in some state” times “spin 2 in some state”?</p>
<p>Try it: if spin 1 is <span class="math inline">\((a|\uparrow\rangle + b|\downarrow\rangle)\)</span> and spin 2 is <span class="math inline">\((c|\uparrow\rangle + d|\downarrow\rangle)\)</span>, the combined state would be: <span class="math display">\[
ac|\uparrow\uparrow\rangle + ad|\uparrow\downarrow\rangle + bc|\downarrow\uparrow\rangle + bd|\downarrow\downarrow\rangle
\]</span></p>
<p>For this to equal <span class="math inline">\(\frac{1}{\sqrt{2}}|\uparrow\uparrow\rangle + \frac{1}{\sqrt{2}}|\downarrow\downarrow\rangle\)</span>, we’d need <span class="math inline">\(ac = bd = \frac{1}{\sqrt{2}}\)</span> and <span class="math inline">\(ad = bc = 0\)</span>. But if <span class="math inline">\(ad = 0\)</span>, then either <span class="math inline">\(a=0\)</span> or <span class="math inline">\(d=0\)</span>, which would make <span class="math inline">\(ac = 0\)</span> or <span class="math inline">\(bd = 0\)</span>. Contradiction!</p>
<p>This state <strong>cannot</strong> be written as a product. The two spins are <strong>entangled</strong>—their fates are correlated in a way that has no classical analog. We’ll explore entanglement much more in future lectures.</p>
</section>
<section id="n-spins-the-exponential-wall" class="level3">
<h3 class="anchored" data-anchor-id="n-spins-the-exponential-wall">N Spins: The Exponential Wall</h3>
<p>Now let’s generalize. For <span class="math inline">\(N\)</span> spins:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><span class="math inline">\(N\)</span> spins</th>
<th>Configurations</th>
<th>State vector size</th>
<th>Matrix size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>2</td>
<td>2 × 2</td>
</tr>
<tr class="even">
<td>2</td>
<td>4</td>
<td>4</td>
<td>4 × 4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>8</td>
<td>8</td>
<td>8 × 8</td>
</tr>
<tr class="even">
<td>10</td>
<td>1,024</td>
<td>1,024</td>
<td>1,024 × 1,024</td>
</tr>
<tr class="odd">
<td>20</td>
<td>~1 million</td>
<td>~1 million</td>
<td>~<span class="math inline">\(10^{12}\)</span> entries</td>
</tr>
<tr class="even">
<td><span class="math inline">\(N\)</span></td>
<td><span class="math inline">\(2^N\)</span></td>
<td><span class="math inline">\(2^N\)</span></td>
<td><span class="math inline">\(2^N \times 2^N\)</span></td>
</tr>
</tbody>
</table>
<p>The general quantum state is a superposition over all <span class="math inline">\(2^N\)</span> configurations: <span class="math display">\[
|\psi\rangle = \sum_{\text{all } 2^N \text{ configs}} c_{\text{config}} \,|\text{config}\rangle
\]</span></p>
<p>Or in vector form: <span class="math display">\[
|\psi\rangle = \begin{pmatrix} c_{00\cdots0} \\ c_{00\cdots1} \\ \vdots \\ c_{11\cdots1} \end{pmatrix} \leftarrow 2^N \text{ amplitudes}
\]</span></p>
<p>Time evolution: <span class="math display">\[
|\psi(t+\Delta t)\rangle = \underbrace{U}_{2^N \times 2^N} \, |\psi(t)\rangle
\]</span></p>
</section>
<section id="the-cost-of-simulating-quantum-mechanics" class="level3">
<h3 class="anchored" data-anchor-id="the-cost-of-simulating-quantum-mechanics">The Cost of Simulating Quantum Mechanics</h3>
<p>The computational cost to simulate one time step: <span class="math display">\[
\text{Cost} \sim (2^N)^2 = 2^{2N}
\]</span></p>
<p>For <span class="math inline">\(T\)</span> time steps: <span class="math display">\[
\text{Total cost} \sim 2^{2N} \times T
\]</span></p>
<p><strong>This is why quantum mechanics is hard to simulate.</strong></p>
<p>For 50 spins, you need a matrix with <span class="math inline">\((2^{50})^2 \approx 10^{30}\)</span> entries. No computer on Earth—no computer that could ever exist—can store that.</p>
<p>And yet nature does this effortlessly. Every atom, every molecule, every piece of matter is constantly “computing” quantum evolution with exponentially many configurations.</p>
<hr>
</section>
</section>
<section id="measurement-the-collapse" class="level2">
<h2 class="anchored" data-anchor-id="measurement-the-collapse">Measurement: The Collapse</h2>
<p>We’ve seen that quantum states can be superpositions of exponentially many configurations. But here’s the catch:</p>
<blockquote class="blockquote">
<p><strong>When you measure a quantum system, you get one classical outcome.</strong></p>
</blockquote>
<p>Consider a single spin in superposition: <span class="math display">\[
|\psi\rangle = \frac{1}{\sqrt{2}}|\uparrow\rangle + \frac{1}{\sqrt{2}}|\downarrow\rangle
\]</span></p>
<p>If we measure the spin—say, by sending it through a <strong>Stern-Gerlach apparatus</strong> (a device that uses a magnetic field gradient to spatially separate spin-up from spin-down)—we don’t get “both.” We get either <span class="math inline">\(\uparrow\)</span> or <span class="math inline">\(\downarrow\)</span>.</p>
<p>The probabilities are given by the <strong>Born rule</strong>: <span class="math display">\[
P(\uparrow) = |c_\uparrow|^2, \qquad P(\downarrow) = |c_\downarrow|^2
\]</span></p>
<p>In this case, <span class="math inline">\(P(\uparrow) = P(\downarrow) = 1/2\)</span>. It’s a coin flip.</p>
<p>After measurement, the state <strong>collapses</strong> to the measured outcome: - If we measure <span class="math inline">\(\uparrow\)</span>, the state becomes <span class="math inline">\(|\uparrow\rangle\)</span> - If we measure <span class="math inline">\(\downarrow\)</span>, the state becomes <span class="math inline">\(|\downarrow\rangle\)</span></p>
<p>The superposition is destroyed. This is one of the deep mysteries of quantum mechanics—but for now, we take it as a rule.</p>
<section id="the-fundamental-tension" class="level3">
<h3 class="anchored" data-anchor-id="the-fundamental-tension">The Fundamental Tension</h3>
<p>This creates a fundamental tension for quantum computing:</p>
<ul>
<li><strong>Before measurement:</strong> The state has <span class="math inline">\(2^N\)</span> amplitudes, all evolving and interfering</li>
<li><strong>After measurement:</strong> We get just <span class="math inline">\(N\)</span> classical bits (one per spin)</li>
</ul>
<p>We put in <span class="math inline">\(N\)</span> bits, we get out <span class="math inline">\(N\)</span> bits. Where did the exponential complexity go?</p>
<p>The answer: the <span class="math inline">\(2^N\)</span> amplitudes don’t disappear—they <strong>interfere</strong>. During the computation, amplitudes flow between configurations. When they meet, they can add (constructive interference) or cancel (destructive interference). By the time we measure, the interference has concentrated probability onto a small number of outcomes.</p>
<p>The exponential complexity was used to orchestrate interference—it shaped <em>which</em> outcomes are likely.</p>
</section>
<section id="a-common-misconception" class="level3">
<h3 class="anchored" data-anchor-id="a-common-misconception">A Common Misconception</h3>
<p>It’s tempting to think: “A quantum computer tries all <span class="math inline">\(2^N\)</span> answers simultaneously and just picks the best one.”</p>
<p><strong>This is wrong.</strong></p>
<p>Measurement doesn’t return the best answer—it returns a <em>random</em> answer, weighted by the squared amplitudes. If you just put a quantum computer in superposition and measured, you’d get a random configuration. That’s no better than guessing!</p>
<p>The hard part is designing the quantum operations so that the <em>right</em> answer has high probability. This requires carefully engineering interference—making wrong answers cancel and right answers reinforce.</p>
<hr>
</section>
</section>
<section id="what-is-a-quantum-computer" class="level2">
<h2 class="anchored" data-anchor-id="what-is-a-quantum-computer">What Is a Quantum Computer?</h2>
<p>We now have all the pieces. A quantum computer is:</p>
<section id="prepare-an-initial-state" class="level3">
<h3 class="anchored" data-anchor-id="prepare-an-initial-state">1. Prepare an Initial State</h3>
<p>Start with all qubits in a known configuration, typically all zeros: <span class="math display">\[
|00\cdots0\rangle
\]</span></p>
<p>This is easy—it’s just a classical state.</p>
</section>
<section id="evolve-through-quantum-gates" class="level3">
<h3 class="anchored" data-anchor-id="evolve-through-quantum-gates">2. Evolve Through Quantum Gates</h3>
<p>Apply a sequence of operations (called <strong>quantum gates</strong>) that cause the wavefunction to spread across configurations.</p>
<p>Each gate is a unitary matrix. Simple gates act on one or two qubits at a time, but their combined effect creates superpositions over all <span class="math inline">\(2^N\)</span> configurations.</p>
</section>
<section id="exploit-interference" class="level3">
<h3 class="anchored" data-anchor-id="exploit-interference">3. Exploit Interference</h3>
<p>Here’s the key insight. If amplitude flows from configuration A to configuration B by two different paths, and those paths come back together, the amplitudes <strong>interfere</strong>:</p>
<ul>
<li><strong>Same phase → constructive interference:</strong> amplitudes add, probability increases</li>
<li><strong>Opposite phase → destructive interference:</strong> amplitudes cancel, probability decreases</li>
</ul>
<pre><code>Path 1:  A ──────→ B   (phase φ₁)
                   ↘
                    ⊕ → Interference!
                   ↗
Path 2:  A ──────→ B   (phase φ₂)

If φ₁ = φ₂:  amplitudes ADD      → high probability
If φ₁ = φ₂ + π: amplitudes CANCEL → low probability</code></pre>
<p>This is exactly like the double-slit experiment, but now it’s happening in the abstract space of all <span class="math inline">\(2^N\)</span> configurations.</p>
</section>
<section id="measure-at-the-end" class="level3">
<h3 class="anchored" data-anchor-id="measure-at-the-end">4. Measure at the End</h3>
<p>Finally, measure all the qubits. The superposition collapses to a single classical outcome: <span class="math display">\[
|001011010\cdots\rangle
\]</span></p>
<p>Just a string of 0s and 1s.</p>
</section>
<section id="the-goal" class="level3">
<h3 class="anchored" data-anchor-id="the-goal">The Goal</h3>
<p>The art of quantum algorithms is designing the gates so that: - <strong>Wrong answers</strong> interfere <strong>destructively</strong> → low probability - <strong>Right answers</strong> interfere <strong>constructively</strong> → high probability</p>
<p>When you measure, you’re likely to get the right answer.</p>
<p>This is not magic. It’s engineering interference patterns in a <span class="math inline">\(2^N\)</span>-dimensional space.</p>
<hr>
</section>
</section>
<section id="summary-classical-vs.-quantum" class="level2">
<h2 class="anchored" data-anchor-id="summary-classical-vs.-quantum">Summary: Classical vs.&nbsp;Quantum</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 41%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Classical</th>
<th>Quantum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>State</strong></td>
<td>One configuration</td>
<td>Superposition of all <span class="math inline">\(2^N\)</span> configurations</td>
</tr>
<tr class="even">
<td><strong>Stored information</strong></td>
<td><span class="math inline">\(N\)</span> bits</td>
<td><span class="math inline">\(2^N\)</span> complex amplitudes</td>
</tr>
<tr class="odd">
<td><strong>Evolution</strong></td>
<td>Update one configuration</td>
<td>Matrix multiply all amplitudes</td>
</tr>
<tr class="even">
<td><strong>Exploration</strong></td>
<td>One path at a time</td>
<td>All paths simultaneously</td>
</tr>
<tr class="odd">
<td><strong>Output</strong></td>
<td>Deterministic</td>
<td>Probabilistic (via interference)</td>
</tr>
</tbody>
</table>
<p>The exponential state space is both the <strong>source of quantum power</strong> and the <strong>reason quantum systems are hard to simulate classically</strong>.</p>
<section id="whats-next" class="level3">
<h3 class="anchored" data-anchor-id="whats-next">What’s Next?</h3>
<p>In the coming lectures, we’ll see specific algorithms that exploit this structure: - <strong>Deutsch-Jozsa</strong>: determining global properties of functions - <strong>Grover’s algorithm</strong>: searching unsorted databases with quadratic speedup<br>
- <strong>Shor’s algorithm</strong>: factoring integers exponentially faster than any known classical method</p>
<p>These algorithms are not just “faster classical algorithms”—they use interference in fundamentally new ways.</p>
<hr>
</section>
</section>
</section>
<section id="homework-part-of-hw-2" class="level1">
<h1>Homework (Part of HW 2)</h1>
<section id="problem-1-ising-energy-by-hand" class="level2">
<h2 class="anchored" data-anchor-id="problem-1-ising-energy-by-hand">Problem 1: Ising Energy by Hand</h2>
<p>Consider 4 spins in a line with the Hamiltonian: <span class="math display">\[
H = -J \sum_{i=1}^{3} s_i s_{i+1} - B \sum_{i=1}^{4} s_i
\]</span></p>
<p>with <span class="math inline">\(J = 1\)</span> (ferromagnetic) and <span class="math inline">\(B = 0.5\)</span>.</p>
<p><strong>(a)</strong> Calculate the energy for <span class="math inline">\(s = [+1, +1, +1, +1]\)</span>.</p>
<p><strong>(b)</strong> Calculate the energy for <span class="math inline">\(s = [+1, -1, +1, -1]\)</span>.</p>
<p><strong>(c)</strong> Find the ground state(s) by checking all 16 configurations. You may use Python or do by hand. If multiple configurations have the same lowest energy, list all of them.</p>
<p><strong>(d)</strong> What is the ground state if <span class="math inline">\(B = 0\)</span>? (Hint: there may be more than one!) Explain physically why there is degeneracy.</p>
<p><strong>(e)</strong> What is the ground state if <span class="math inline">\(B = 10\)</span>? Why is it unique now?</p>
</section>
<section id="problem-2-phase-transition-in-the-antiferromagnet" class="level2">
<h2 class="anchored" data-anchor-id="problem-2-phase-transition-in-the-antiferromagnet">Problem 2: Phase Transition in the Antiferromagnet</h2>
<p>Now consider an <strong>antiferromagnetic</strong> chain with <span class="math inline">\(N = 10\)</span> spins: <span class="math display">\[
H = -J \sum_{i=1}^{N-1} s_i s_{i+1} - B \sum_{i=1}^{N} s_i
\]</span></p>
<p>with <span class="math inline">\(J = -1\)</span> (antiferromagnetic, so neighboring spins want to anti-align).</p>
<p><strong>(a)</strong> What is the ground state when <span class="math inline">\(B = 0\)</span>? What is its energy? (Note: there may be two degenerate ground states—list both if so.)</p>
<p><strong>(b)</strong> What is the ground state when <span class="math inline">\(B = 100\)</span>? What is its energy?</p>
<p><strong>(c)</strong> Write a Python program to find the ground state (by brute force) for values of <span class="math inline">\(B\)</span> from 0 to 5 in steps of 0.25. For each <span class="math inline">\(B\)</span>, record: - The ground state configuration(s) (if there are ties, pick one) - The ground state energy - The “magnetization” <span class="math inline">\(m = \frac{1}{N}\sum_i s_i\)</span> (average spin)</p>
<p><strong>(d)</strong> Plot the magnetization <span class="math inline">\(m\)</span> versus <span class="math inline">\(B\)</span>. At what value of <span class="math inline">\(B\)</span> does the ground state change from the alternating pattern to the fully aligned state? This is the <strong>critical field</strong> <span class="math inline">\(B_c\)</span> of the phase transition.</p>
<p><strong>(e)</strong> Explain in 2-3 sentences why the transition happens at this particular value of <span class="math inline">\(B\)</span>.</p>
<p><strong>(f)</strong> <strong>(Optional)</strong> Derive the critical field analytically. Compare the energy of the alternating state <span class="math inline">\(E_{\text{alt}}\)</span> to the energy of the all-up state <span class="math inline">\(E_{\text{up}}\)</span> and find the value of <span class="math inline">\(B\)</span> where they cross.</p>
</section>
<section id="problem-3-simulated-annealing" class="level2">
<h2 class="anchored" data-anchor-id="problem-3-simulated-annealing">Problem 3: Simulated Annealing</h2>
<p>Implement simulated annealing to find the ground state of the antiferromagnetic chain from Problem 2.</p>
<p><strong>(a)</strong> Write a Python function <code>simulated_annealing(J, B, N, T_init, T_final, steps)</code> that: - Starts with a random spin configuration - Proposes single spin flips - Accepts/rejects according to the Metropolis criterion: accept if <span class="math inline">\(\Delta E &lt; 0\)</span>, otherwise accept with probability <span class="math inline">\(e^{-\Delta E/T}\)</span> - Gradually cools from <code>T_init</code> to <code>T_final</code> over <code>steps</code> iterations</p>
<p>You can use either linear cooling (<code>T = T_init - (T_init - T_final) * step / steps</code>) or exponential cooling (<code>T = T_init * (T_final / T_init)^(step / steps)</code>). Exponential cooling is often more effective.</p>
<p><strong>(b)</strong> Run your algorithm for <span class="math inline">\(N = 10\)</span>, <span class="math inline">\(J = -1\)</span>, <span class="math inline">\(B = 1\)</span>, with <span class="math inline">\(T_{\text{init}} = 10\)</span>, <span class="math inline">\(T_{\text{final}} = 0.01\)</span>, and 10,000 steps. Plot the energy versus iteration number.</p>
<p><strong>(c)</strong> Does your algorithm find the true ground state (which you know from Problem 2c)? Run it 10 times and report how often it succeeds. Consider it a “success” if the final energy matches the brute-force ground state energy to within 0.01.</p>
<p><strong>(d)</strong> Now try <span class="math inline">\(N = 30\)</span>, <span class="math inline">\(J = -1\)</span>, <span class="math inline">\(B = 1\)</span>. You can no longer verify by brute force. Run simulated annealing 10 times and report the lowest energy found. How consistent are the results?</p>
<p><em>Hint: For</em> <span class="math inline">\(N = 30\)</span> antiferromagnetic with <span class="math inline">\(B = 1\)</span>, the ground state energy should be around <span class="math inline">\(E \approx -39\)</span>. If you’re getting energies much higher than this, try increasing the number of steps or adjusting your cooling schedule.</p>
<p><strong>Starter code:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_energy(s, J, B):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute Ising energy for configuration s.</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    s: array of +1/-1 values</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    J: nearest-neighbor coupling</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    B: external field</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    interaction <span class="op">=</span> <span class="op">-</span>J <span class="op">*</span> np.<span class="bu">sum</span>(s[:<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> s[<span class="dv">1</span>:])</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    field <span class="op">=</span> <span class="op">-</span>B <span class="op">*</span> np.<span class="bu">sum</span>(s)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> interaction <span class="op">+</span> field</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing(J, B, N, T_init, T_final, steps):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Find low-energy spin configuration using simulated annealing.</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns: final configuration, final energy, energy history</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize random configuration</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> np.random.choice([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>], size<span class="op">=</span>N)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    E <span class="op">=</span> compute_energy(s, J, B)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    energy_history <span class="op">=</span> [E]</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(steps):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Exponential cooling schedule</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> T_init <span class="op">*</span> (T_final <span class="op">/</span> T_init) <span class="op">**</span> (step <span class="op">/</span> steps)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Your code here:</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 1. Pick a random spin index i</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2. Compute energy change ΔE if we flip spin i</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">#    (Hint: you don't need to recompute the full energy—</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">#     only the terms involving spin i change)</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3. Accept or reject according to Metropolis criterion</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 4. If accepted, flip the spin and update E</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        energy_history.append(E)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s, E, energy_history</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Test your implementation</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>s_final, E_final, history <span class="op">=</span> simulated_annealing(J<span class="op">=-</span><span class="dv">1</span>, B<span class="op">=</span><span class="dv">1</span>, N<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                                                  T_init<span class="op">=</span><span class="dv">10</span>, T_final<span class="op">=</span><span class="fl">0.01</span>, </span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                                                  steps<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final energy: </span><span class="sc">{</span>E_final<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final configuration: </span><span class="sc">{</span>s_final<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>plt.plot(history)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Step'</span>)</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Energy'</span>)</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Simulated Annealing'</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="problem-4-quantum-state-vectors" class="level2">
<h2 class="anchored" data-anchor-id="problem-4-quantum-state-vectors">Problem 4: Quantum State Vectors</h2>
<p><strong>(a)</strong> A single spin is in the state: <span class="math display">\[
|\psi\rangle = \frac{1}{2}|\uparrow\rangle + \frac{\sqrt{3}}{2}|\downarrow\rangle
\]</span> - Verify this state is normalized. - What is the probability of measuring spin up? Spin down? - If you measured 1000 spins prepared in this state, how many would you expect to find spin up?</p>
<p><strong>(b)</strong> Write out the state vector for two spins where: - The first spin is <span class="math inline">\(|\uparrow\rangle\)</span> - The second spin is in equal superposition: <span class="math inline">\(\frac{1}{\sqrt{2}}(|\uparrow\rangle + |\downarrow\rangle)\)</span></p>
<p>The combined state of two independent systems is their <strong>tensor product</strong>: <span class="math inline">\(|\psi_1\rangle \otimes |\psi_2\rangle\)</span>. This means you multiply every amplitude of the first system by every amplitude of the second.</p>
<p>Express your answer as a 4-component vector in the basis <span class="math inline">\(\{|\uparrow\uparrow\rangle, |\uparrow\downarrow\rangle, |\downarrow\uparrow\rangle, |\downarrow\downarrow\rangle\}\)</span>.</p>
<p><strong>(c)</strong> How many complex amplitudes are needed to describe: - 5 spins? - 10 spins? - 50 spins?</p>
<p><strong>(d)</strong> If each complex amplitude requires 16 bytes to store (8 bytes for the real part, 8 for imaginary), how much memory is needed to store the state vector for 30 spins? Compare to your computer’s RAM.</p>
</section>
<section id="problem-5-why-unitary" class="level2">
<h2 class="anchored" data-anchor-id="problem-5-why-unitary">Problem 5: Why Unitary?</h2>
<p>Time evolution in quantum mechanics must preserve probability. Let’s prove that this requires the evolution matrix to be unitary.</p>
<p>A single spin has state: <span class="math display">\[
|\psi\rangle = \begin{pmatrix} c_0 \\ c_1 \end{pmatrix}
\]</span></p>
<p>The normalization condition is <span class="math inline">\(|c_0|^2 + |c_1|^2 = 1\)</span>.</p>
<p>After time evolution by matrix <span class="math inline">\(U\)</span>: <span class="math display">\[
\begin{pmatrix} c_0' \\ c_1' \end{pmatrix} = \begin{pmatrix} U_{00} &amp; U_{01} \\ U_{10} &amp; U_{11} \end{pmatrix} \begin{pmatrix} c_0 \\ c_1 \end{pmatrix}
\]</span></p>
<p><strong>(a)</strong> Write out <span class="math inline">\(c_0'\)</span> and <span class="math inline">\(c_1'\)</span> in terms of the matrix elements <span class="math inline">\(U_{ij}\)</span> and the original amplitudes.</p>
<p><strong>(b)</strong> For probability to be conserved (i.e., <span class="math inline">\(|c_0'|^2 + |c_1'|^2 = 1\)</span>) for <em>any</em> normalized initial state, what conditions must the columns of <span class="math inline">\(U\)</span> satisfy?</p>
<p><em>Hint: Try specific initial states like</em> <span class="math inline">\(|\psi\rangle = (1, 0)^T\)</span> and <span class="math inline">\(|\psi\rangle = (0, 1)^T\)</span> first.</p>
<p><strong>(c)</strong> Show that the condition from (b) can be written as <span class="math inline">\(U^\dagger U = I\)</span>, where <span class="math inline">\(U^\dagger\)</span> is the conjugate transpose (transpose, then complex conjugate each entry). A matrix satisfying this is called <strong>unitary</strong>.</p>
<p><strong>(d)</strong> Verify that the following matrix is unitary: <span class="math display">\[
H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}
\]</span></p>
<p>This is called the <strong>Hadamard gate</strong>—one of the most important gates in quantum computing.</p>
<p>l3t’ ## Problem 6: The Exponential Wall (Short Essay)</p>
<p>In approximately half a page, answer the following:</p>
<p><strong>(a)</strong> Why can’t classical computers efficiently simulate large quantum systems? Be specific about what scales exponentially.</p>
<p><strong>(b)</strong> Nature simulates quantum systems effortlessly—every molecule is constantly evolving quantum mechanically. Why can’t we just “use nature” to solve computational problems? What’s the key property that a quantum computer has that a random molecule doesn’t?</p>
<p><strong>(c)</strong> A quantum computer with 50 qubits has a state vector with <span class="math inline">\(2^{50} \approx 10^{15}\)</span> amplitudes. But when we measure, we only get 50 bits of output. Explain how this is useful for computation. Your answer should include the word “interference.”</p>
<p>% ## Problem 7: The Wedding Problem Revisited (Optional Challenge)</p>
<p>% Apply simulated annealing to the 30-guest wedding problem from last week.</p>
<p>% <strong>(a)</strong> Adapt your code to work with permutations instead of spin flips. A natural “move” is to swap two randomly chosen guests.</p>
<p>% <strong>(b)</strong> Compare your best result from simulated annealing to your best result from last week. Did you do better?</p>
<p>% <strong>(c)</strong> In 2-3 sentences: why might the wedding problem ($N!$ configurations) be harder for simulated annealing than the spin problem ($2^N$ configurations)?</p>
<p>% <em>Hint: Think about what happens when you swap two guests vs.&nbsp;flip one spin. How much does the energy typically change? How “rough” is the energy landscape?</em></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>